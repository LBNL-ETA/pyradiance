{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Pyradiance is a Python wrapper to the validated  RADIANCE ray-tracing system  that mimics closely the RADIANCE CLI. See Reference for a complete  list of supported RADIANCE functions.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pyradiance can be installed via pip from PyPI: <pre><code>pip install pyradiance\n</code></pre> This command will install also Radiance binaries and libraries files,  setting up the PATH environment. You don't need to install Radiance  separately. If you already have RADIANCE installed  in your system, pyradiance won't interfere with it either.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python &gt;= 3.8</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>For new users, here is a quickstart tutorial</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>This work was supported by the Assistant Secretary for Energy Efficiency and Renewable Energy, Building Technologies Program, of the U.S. Department of Energy, under Contract No. DE-AC02-05CH11231.</p>"},{"location":"how-to-guides/","title":"Under construction","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pyradiance","title":"<code>pyradiance</code>","text":"<p>pyradiance is a Python interface for Radiance. It is a collection of Python modules that provide a high level interface to Radiance. It is designed to make Radiance easier to use and accessible to Python user.</p>"},{"location":"reference/#pyradiance.Primitive","title":"<code>Primitive</code>  <code>dataclass</code>","text":"<p>Radiance Primitive.</p> <p>Attributes one-to-one mapped from Radiance.</p> <p>Attributes:</p>    Name Type Description     <code>modifier</code>  <code>str</code>  <p>modifier, which primitive modifies this one</p>   <code>ptype</code>  <code>str</code>  <p>primitive type</p>   <code>identifier</code>  <code>str</code>  <p>identifier, name of this primitive</p>   <code>sargs</code>  <code>Sequence[str]</code>  <p>string arguments</p>   <code>fargs</code>  <code>Sequence[float]</code>  <p>real arguments</p>"},{"location":"reference/#pyradiance.RcModifier","title":"<code>RcModifier</code>  <code>dataclass</code>","text":"<p>Modifier for rcontrib command.</p> <p>Attributes:</p>    Name Type Description     <code>modifier</code>  <code>Optional[str]</code>  <p>Modifier name, mutually exclusive with modifier_path.</p>   <code>modifier_path</code>  <code>Optional[str]</code>  <p>File with modifier names, mutually exclusive with modifier.</p>   <code>calfile</code>  <code>Optional[str]</code>  <p>Calc file path.</p>   <code>expression</code>  <code>Optional[str]</code>  <p>Variable and function expressions.</p>   <code>nbins</code>  <code>Optional[str]</code>  <p>Number of bins, can be expression.</p>   <code>binv</code>  <code>Optional[str]</code>  <p>Bin value.</p>   <code>param</code>  <code>Optional[str]</code>  <p>Parameter.</p>   <code>xres</code>  <code>Optional[int]</code>  <p>X resolution.</p>   <code>yres</code>  <code>Optional[int]</code>  <p>Y resolution.</p>   <code>output</code>  <code>Optional[str]</code>  <p>Output file.</p>"},{"location":"reference/#pyradiance.rt.RcModifier.args","title":"<code>args()</code>","text":"<p>Return modifier as a list of arguments.</p>"},{"location":"reference/#pyradiance.Scene","title":"<code>Scene</code>","text":"<p>Radiance Scene.</p>"},{"location":"reference/#pyradiance.model.Scene.materials","title":"<code>materials</code>  <code>property</code>","text":"<p>Scene materials.</p>"},{"location":"reference/#pyradiance.model.Scene.sid","title":"<code>sid: str</code>  <code>property</code>","text":"<p>Scene id.</p>"},{"location":"reference/#pyradiance.model.Scene.sources","title":"<code>sources</code>  <code>property</code>","text":"<p>Scene sources.</p>"},{"location":"reference/#pyradiance.model.Scene.surfaces","title":"<code>surfaces</code>  <code>property</code>","text":"<p>Scene surfaces.</p>"},{"location":"reference/#pyradiance.model.Scene.__init__","title":"<code>__init__(sid)</code>","text":"<p>Parameters:</p>    Name Type Description Default     <code>sid</code>  <code>str</code>  <p>scene id</p>  required"},{"location":"reference/#pyradiance.model.Scene.add_material","title":"<code>add_material(material)</code>","text":"<p>Add material to the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>material</code>  <code>Union[str, Path, Primitive]</code>  <p>material to be added</p>  required"},{"location":"reference/#pyradiance.model.Scene.add_sensor","title":"<code>add_sensor(sensor)</code>","text":"<p>Add sensor to the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>sensor</code>  <code>Sequence[float]</code>  <p>sensor to be added</p>  required"},{"location":"reference/#pyradiance.model.Scene.add_source","title":"<code>add_source(source)</code>","text":"<p>Add source to the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>source</code>  <code>Union[str, Path, Primitive]</code>  <p>source to be added</p>  required"},{"location":"reference/#pyradiance.model.Scene.add_surface","title":"<code>add_surface(surface)</code>","text":"<p>Add surface to the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>surface</code>  <code>Union[str, Path, Primitive]</code>  <p>surface to be added</p>  required"},{"location":"reference/#pyradiance.model.Scene.add_view","title":"<code>add_view(view)</code>","text":"<p>Add view to the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>view</code>  <code>View</code>  <p>view to be added</p>  required"},{"location":"reference/#pyradiance.model.Scene.build","title":"<code>build()</code>","text":"<p>Build an octree, as {sid}.oct in the current directory. Will not build if scene has not changed since last build.</p>"},{"location":"reference/#pyradiance.model.Scene.remove_material","title":"<code>remove_material(material)</code>","text":"<p>Remove material from the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>material</code>  <code>Union[str, Path, Primitive]</code>  <p>material to be removed</p>  required"},{"location":"reference/#pyradiance.model.Scene.remove_source","title":"<code>remove_source(source)</code>","text":"<p>Remove source from the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>source</code>  <code>Union[str, Path, Primitive]</code>  <p>source to be removed</p>  required"},{"location":"reference/#pyradiance.model.Scene.remove_surface","title":"<code>remove_surface(surface)</code>","text":"<p>Remove surface from the scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>surface</code>  <code>Union[str, Path, Primitive]</code>  <p>surface to be removed</p>  required"},{"location":"reference/#pyradiance.View","title":"<code>View</code>  <code>dataclass</code>","text":"<p>Radiance View.</p> <p>Attributes:</p>    Name Type Description     <code>vtype</code>  <code>str</code>  <p>view type</p>   <code>position</code>  <code>Tuple[float, float, float]</code>  <p>view position</p>   <code>direction</code>  <code>Tuple[float, float, float]</code>  <p>view direction</p>   <code>vup</code>  <code>Tuple[float, float, float]</code>  <p>view up</p>   <code>horiz</code>  <code>float</code>  <p>horizontal field of view</p>   <code>vert</code>  <code>float</code>  <p>vertical field of view</p>   <code>vfore</code>  <code>float</code>  <p>view fore</p>   <code>vaft</code>  <code>float</code>  <p>view aft</p>   <code>hoff</code>  <code>float</code>  <p>horizontal offset</p>   <code>voff</code>  <code>float</code>  <p>vertical offset</p>"},{"location":"reference/#pyradiance.bsdf2klems","title":"<code>bsdf2klems(*inp, spp=None, half=False, quater=False, progress_bar=False, progress_bar_length=None, maxlobes=None, forward=False, backward=True, expr=None, file=None)</code>","text":"<p>Generate XML Klems matrix description of a BSDF.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>Path to XML file</p>  <code>()</code>    <code>spp</code>  <code>Optional[int]</code>  <p>number of samples for each input-output patch pair, default=1024.</p>  <code>None</code>    <code>half</code>  <code>bool</code>  <p>Generate instead a half Klems basis XML.</p>  <code>False</code>    <code>quater</code>  <code>bool</code>  <p>Generate instead a quater Klems basis XML.</p>  <code>False</code>    <code>progress_bar</code>  <code>bool</code>  <p>toggle to show progress bar.</p>  <code>False</code>    <code>progress_bar_length</code>  <code>Optional[int]</code>  <p>length of the progress bar, default=79 characters.</p>  <code>None</code>    <code>maxlobes</code>  <code>Optional[int]</code>  <p>maximum number of lobes in any interpolated radial basis function (default=15000). Setting the value to 0 turns off this limit.</p>  <code>None</code>    <code>forward</code>  <code>bool</code>  <p>generate forward matrix (default=off).</p>  <code>False</code>    <code>backward</code>  <code>bool</code>  <p>generate backward matrixi (default=on).</p>  <code>True</code>    <code>expr</code>  <code>Optional[str]</code>  <p>expression to evaluate.</p>  <code>None</code>    <code>file</code>  <code>Optional[str]</code>  <p>file to write the output to</p>  <code>None</code>     <p>Returns:</p>    Type Description       <p>The output of the command</p>"},{"location":"reference/#pyradiance.bsdf2ttree","title":"<code>bsdf2ttree(*inp, isotropic=False, reciprocity_averaging=True, resolution=6, percent_cull=[90], super_samples=256, difference_threshold=0.35, progress_bar=False, progress_bar_length=None, maxlobes=15000, forward=False, backward=True, expr=None, file=None)</code>","text":"<p>Generate XML tensor tree description of a BSDF.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>Path to XML file</p>  <code>()</code>    <code>isotropic</code>  <code>bool</code>  <p>Generate an isotropic ttree.</p>  <code>False</code>    <code>reciprocity_averaging</code>  <code>bool</code>  <p>Use reciprocity averaging.</p>  <code>True</code>    <code>resolution</code>  <code>int</code>  <p>resolution of the ttree.</p>  <code>6</code>    <code>percent_cull</code>  <code>Sequence[float]</code>  <p>percent of the ttree to cull.</p>  <code>[90]</code>    <code>super_samples</code>  <code>int</code>  <p>number of samples for each input-output patch pair, default=1024.</p>  <code>256</code>    <code>difference_threshold</code>  <code>float</code>  <p>difference threshold for culling.</p>  <code>0.35</code>    <code>progress_bar</code>  <code>bool</code>  <p>toggle to show progress bar.</p>  <code>False</code>    <code>progress_bar_length</code>  <code>Optional[int]</code>  <p>length of the progress bar, default=79 characters.</p>  <code>None</code>    <code>maxlobes</code>  <code>int</code>  <p>maximum number of lobes in any interpolated radial basis function (default=15000). Setting the value to 0 turns off this limit.</p>  <code>15000</code>    <code>forward</code>  <code>bool</code>  <p>generate forward matrix (default=off).</p>  <code>False</code>    <code>backward</code>  <code>bool</code>  <p>generate backward matrixi (default=on).</p>  <code>True</code>    <code>expr</code>  <code>Optional[str]</code>  <p>expression to evaluate.</p>  <code>None</code>    <code>file</code>  <code>Optional[str]</code>  <p>file to write the output to</p>  <code>None</code>     <p>Returns:</p>    Type Description       <p>Tensor tree BSDF XML in bytes</p>"},{"location":"reference/#pyradiance.cnt","title":"<code>cnt(*dims, shuffled=False)</code>","text":"<p>Index counter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cnt(2, 3)\nb'0 0\\n0 1\\n0 2\\n1 0\\n1 1\\n1 2\\n'\n&gt;&gt;&gt; cnt(2, 3, shuffled=True)\nb'1 2\\n0 1\\n1 0\\n0 2\\n1 1\\n0 0\\n'\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>dims</code>  <code>int</code>  <p>list of dimensions</p>  <code>()</code>    <code>shuffled</code>  <code>bool</code>  <p>if True, the output will be shuffled</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of cnt</p>"},{"location":"reference/#pyradiance.dctimestep","title":"<code>dctimestep(*mtx, nstep=None, header=True, xres=None, yres=None, inform=None, outform=None, ospec=None)</code>","text":"<p>Call dctimestep to perform matrix multiplication.</p> <p>Parameters:</p>    Name Type Description Default     <code>mtx</code>   <p>input matrices</p>  <code>()</code>    <code>nstep</code>  <code>Optional[int]</code>  <p>number of steps</p>  <code>None</code>    <code>header</code>  <code>bool</code>  <p>include header</p>  <code>True</code>    <code>xres</code>  <code>Optional[int]</code>  <p>x resolution</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>y resolution</p>  <code>None</code>    <code>inform</code>  <code>Optional[str]</code>  <p>input format</p>  <code>None</code>    <code>outform</code>  <code>Optional[str]</code>  <p>output format</p>  <code>None</code>    <code>ospec</code>  <code>Optional[str]</code>  <p>output specification</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>Optional[bytes]</code>  <p>output of dctimestep</p>"},{"location":"reference/#pyradiance.genbsdf","title":"<code>genbsdf(*inp, nsamp=1, nproc=1, params=None, enforce_window=False, ttree_rank=None, ttree_res=None, color=False, reciprocity=True, recover_dir=None, forward=False, backward=True, mgf=None, geom=False, geom_unit=None, dim=None, **kwargs)</code>","text":"<p>Generate BSDF description from Radiance or MGF input</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; genbsdf('material.mat', 'blinds.rad', nsamp=50, nproc=4)\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>Union[str, Path]</code>  <p>Input files. This can be a list of files or a single string with</p>  <code>()</code>    <code>nsamp</code>  <code>int</code>  <p>Number of samples to generate. Default is 1.</p>  <code>1</code>    <code>nproc</code>  <code>int</code>  <p>Number of processors to use. Default is 1.</p>  <code>1</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>A list of parameters to pass to genBSDF.</p>  <code>None</code>    <code>enforce_window</code>   <p>Set to True to enforce the window. Default is False.</p>  <code>False</code>    <code>ttree_rank</code>  <code>Optional[int]</code>  <p>Tensor tree rank, 3 for isotropic and 4 for anisotropic BSDF.</p>  <code>None</code>    <code>ttree_res</code>  <code>Optional[int]</code>  <p>Tensor tree BSDF resolution, e.g., 5 6 7.</p>  <code>None</code>    <code>color</code>  <code>bool</code>  <p>Set to True to generate color BSDF. Default is False.</p>  <code>False</code>    <code>reciprocity</code>  <code>bool</code>  <p>Set to False to disable reciprocity. Default is True.</p>  <code>True</code>    <code>recover_dir</code>  <code>Optional[Union[str, Path]]</code>  <p>Set to a path to recover from a previous run.</p>  <code>None</code>    <code>forward</code>  <code>bool</code>  <p>Set to True to generate forward BSDF. Default is False.</p>  <code>False</code>    <code>backward</code>  <code>bool</code>  <p>Set to True to generate backward BSDF. Default is True.</p>  <code>True</code>    <code>mgf</code>  <code>Optional[Union[str, Path]]</code>  <p>Set to a path to a MGF file to use.</p>  <code>None</code>    <code>geom</code>  <code>bool</code>  <p>Set to True to generate geometry BSDF. Default is False.</p>  <code>False</code>    <code>geom_unit</code>  <code>Optional[str]</code>  <p>Set to a unit to use for geometry BSDF.</p>  <code>None</code>    <code>dim</code>  <code>Optional[Sequence[float]]</code>  <p>Set to a list of 6 numbers to use for geometry BSDF.</p>  <code>None</code>    <code>kwargs</code>   <p>Additional parameters to pass to genBSDF.</p>  <code>{}</code>     <p>Returns:</p>    Name Type Description     <code>str</code>  <code>bytes</code>  <p>Output of genBSDF.</p>"},{"location":"reference/#pyradiance.gendaylit","title":"<code>gendaylit(dt, latitude, longitude, timezone, year=None, dirnorm=None, diffhor=None, dirhor=None, dirnorm_illum=None, diffhor_illum=None, solar=False, sky_only=False, silent=False, grefl=None, interval=None)</code>","text":"<p>Generates a RADIANCE description of the daylight sources using Perez models for direct and diffuse components.</p> <p>Parameters:</p>    Name Type Description Default     <code>dt</code>  <code>datetime</code>  <p>python datetime object</p>  required    <code>latitude</code>  <code>float</code>  <p>latitude in degrees</p>  required    <code>longitude</code>  <code>float</code>  <p>longitude in degrees</p>  required    <code>timezone</code>  <code>int</code>  <p>standard meridian timezone, e.g., 120 for PST</p>  required    <code>year</code>  <code>Optional[int]</code>  <p>Need to set it explicitly, won't use year in datetime object</p>  <code>None</code>    <code>dirnorm</code>  <code>Optional[float]</code>  <p>direct normal irradiance</p>  <code>None</code>    <code>diffhor</code>  <code>Optional[float]</code>  <p>diffuse horizontal irradiance</p>  <code>None</code>    <code>dirhor</code>  <code>Optional[float]</code>  <p>direct horizontal irradiance, either this or dirnorm</p>  <code>None</code>    <code>dirnormp</code>   <p>direct normal illuminance</p>  required    <code>diffhorp</code>   <p>diffuse horizontal illuminance</p>  required    <code>solar</code>  <code>bool</code>  <p>if True, include solar position</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>str</code>  <code>bytes</code>  <p>output of gendaylit</p>"},{"location":"reference/#pyradiance.gendaymtx","title":"<code>gendaymtx(weather_data, verbose=False, header=True, average=False, sun_only=False, sky_only=False, sun_file=None, sun_mods=None, daylight_hours_only=False, dryrun=False, sky_color=None, ground_color=None, rotate=None, outform=None, onesun=False, solar_radiance=False, mfactor=1)</code>","text":"<p>Generate an annual Perez sky matrix from a weather tape.</p> <p>Parameters:</p>    Name Type Description Default     <code>weather_data</code>  <code>Union[str, Path, bytes]</code>  <p>weather data</p>  required    <code>mfactor</code>  <code>int</code>  <p>multiplication factor</p>  <code>1</code>    <code>verbose</code>  <code>bool</code>  <p>verbose</p>  <code>False</code>    <code>header</code>  <code>bool</code>  <p>header</p>  <code>True</code>    <code>average</code>  <code>bool</code>  <p>average</p>  <code>False</code>    <code>sun_only</code>  <code>bool</code>  <p>sun only</p>  <code>False</code>    <code>sky_only</code>  <code>bool</code>  <p>sky only</p>  <code>False</code>    <code>sun_file</code>  <code>Optional[str]</code>  <p>sun file</p>  <code>None</code>    <code>sun_mods</code>  <code>Optional[str]</code>  <p>sun mods</p>  <code>None</code>    <code>daylight_hours_only</code>  <code>bool</code>  <p>daylight hours only</p>  <code>False</code>    <code>dryrun</code>  <code>bool</code>  <p>dryrun</p>  <code>False</code>    <code>sky_color</code>  <code>Optional[List[float]]</code>  <p>sky color</p>  <code>None</code>    <code>ground_color</code>  <code>Optional[List[float]]</code>  <p>ground color</p>  <code>None</code>    <code>rotate</code>  <code>Optional[float]</code>  <p>rotate</p>  <code>None</code>    <code>outform</code>  <code>Optional[str]</code>  <p>outform</p>  <code>None</code>    <code>onesun</code>  <code>bool</code>  <p>onesun</p>  <code>False</code>    <code>solar_radiance</code>  <code>bool</code>  <p>solar radiance</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>   <p>output of gendaymtx</p>"},{"location":"reference/#pyradiance.gensky","title":"<code>gensky(dt=None, latitude=None, longitude=None, timezone=None, altitude=None, azimuth=None, year=None, sunny_with_sun=False, sunny_without_sun=False, cloudy=False, intermediate_with_sun=False, intermediate_without_sun=False, uniform=False, ground_reflectance=None, zenith_brightness=None, horizontal_brightness=None, solar_radiance=None, horizontal_direct_irradiance=None, turbidity=None)</code>","text":"<p>Generate a RADIANCE description of the sky.</p> <p>Parameters:</p>    Name Type Description Default     <code>dt</code>  <code>Optional[datetime]</code>  <p>datetime object, mutally exclusive with altitude and azimuth</p>  <code>None</code>    <code>latitude</code>  <code>Optional[float]</code>  <p>latitude, only apply if dt is not None</p>  <code>None</code>    <code>longitude</code>  <code>Optional[float]</code>  <p>longitude, only apply if dt is not None</p>  <code>None</code>    <code>timezone</code>  <code>Optional[int]</code>  <p>timezone, only apply if dt is not None</p>  <code>None</code>    <code>altitude</code>  <code>Optional[float]</code>  <p>solar altitude, mutally exclusive with dt</p>  <code>None</code>    <code>azimuth</code>  <code>Optional[float]</code>  <p>solar azimuth, mutally exclusive with dt</p>  <code>None</code>    <code>year</code>  <code>Optional[int]</code>  <p>year, only apply if dt is not None</p>  <code>None</code>    <code>sunny_with_sun</code>  <code>bool</code>  <p>sunny with sun</p>  <code>False</code>    <code>sunny_without_sun</code>  <code>bool</code>  <p>sunny without sun</p>  <code>False</code>    <code>cloudy</code>  <code>bool</code>  <p>CIE overcast sky</p>  <code>False</code>    <code>intermediate_with_sun</code>  <code>bool</code>  <p>intermediate with sun</p>  <code>False</code>    <code>intermediate_without_sun</code>  <code>bool</code>  <p>intermediate without sun</p>  <code>False</code>    <code>uniform</code>  <code>bool</code>  <p>uniform sky</p>  <code>False</code>    <code>ground_reflectance</code>  <code>Optional[float]</code>  <p>ground reflectance</p>  <code>None</code>    <code>zenith_brightness</code>  <code>Optional[float]</code>  <p>zenith brightness in watts/steradian/meter^2</p>  <code>None</code>    <code>horizontal_brightness</code>  <code>Optional[float]</code>  <p>horizontal brightness in watts/metere^2</p>  <code>None</code>    <code>solar_radiance</code>  <code>Optional[float]</code>  <p>solar radiance in watts/steradian/meter^2</p>  <code>None</code>    <code>horizontal_direct_irradiance</code>  <code>Optional[float]</code>  <p>horizontal direct irradiance in watts/meter^2</p>  <code>None</code>    <code>turbidity</code>  <code>Optional[float]</code>  <p>turbidity factor</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>str</code>  <code>bytes</code>  <p>output of gensky</p>"},{"location":"reference/#pyradiance.get_header","title":"<code>get_header(inp, dimension=False)</code>","text":"<p>Get header information from a Radiance file.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>input file or bytes</p>  required     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>header</p>"},{"location":"reference/#pyradiance.get_image_dimensions","title":"<code>get_image_dimensions(image)</code>","text":"<p>Get the dimensions of an image.</p> <p>Parameters:</p>    Name Type Description Default     <code>image</code>  <code>Union[str, Path, bytes]</code>  <p>image file or bytes</p>  required     <p>Returns:</p>    Type Description      <code>Tuple[int, int]</code>  <p>Tuple[int, int]: width and height</p>"},{"location":"reference/#pyradiance.getinfo","title":"<code>getinfo(*inputs, dimension_only=False, dimension=False, strip_header=False, replace='', append='', command='')</code>","text":"<p>Get header information from a Radiance file.</p> <p>Parameters:</p>    Name Type Description Default     <code>inputs</code>  <code>Union[str, Path, bytes]</code>  <p>input file or bytes</p>  <code>()</code>    <code>dimension_only</code>  <code>bool</code>  <p>return only the dimension</p>  <code>False</code>    <code>dimension</code>  <code>bool</code>  <p>return the dimension</p>  <code>False</code>    <code>strip_header</code>  <code>bool</code>  <p>strip header from the output</p>  <code>False</code>    <code>replace</code>  <code>str</code>  <p>replace the header with this string</p>  <code>''</code>    <code>append</code>  <code>str</code>  <p>append this string to the header</p>  <code>''</code>    <code>command</code>  <code>str</code>  <p>command to use to get the header</p>  <code>''</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>getinfo output</p>"},{"location":"reference/#pyradiance.ies2rad","title":"<code>ies2rad(*inp, libdir=None, prefdir=None, outname=None, stdout=False, units=None, radius=None, instancing_geometry=False, lampdat=None, lamp_type=None, lamp_color=None, set_default_lamp_color=None, multiply_factor=None)</code>","text":"<p>Convert IES luminaire data to RADIANCE description.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>Union[str, Path]</code>  <p>Path to IES file</p>  <code>()</code>    <code>libdir</code>  <code>Optional[str]</code>  <p>Path to directory where the library files are located.</p>  <code>None</code>    <code>outname</code>  <code>Optional[str]</code>  <p>Output file name root.</p>  <code>None</code>    <code>stdout</code>  <code>bool</code>  <p>Print the output to stdout.</p>  <code>False</code>    <code>units</code>  <code>Optional[str]</code>  <p>Set the units of the output file.</p>  <code>None</code>    <code>rad</code>   <p>ignore the crude geometry given by the IES input file and use instead an illum sphere with radius rad.</p>  required    <code>instancing_geometry</code>  <code>bool</code>  <p>compile MGF detail geometry into a separate octree and create a single instance referencing it.</p>  <code>False</code>    <code>lampdat</code>  <code>Optional[str]</code>  <p>map lamp name to xy chromaticity and lumen depreciation data.</p>  <code>None</code>    <code>lamp_type</code>  <code>Optional[str]</code>  <p>lamp type.</p>  <code>None</code>    <code>lamp_color</code>  <code>Optional[str]</code>  <p>set lamp color to red green blue if lamp type is unknown.</p>  <code>None</code>    <code>set_default_lamp_color</code>  <code>Optional[str]</code>  <p>set default lamp color according to the entry for lamp in the lookup table.</p>  <code>None</code>    <code>multiply_factor</code>  <code>Optional[float]</code>  <p>multiply all output quantities by this factor. This is the best way to scale fixture brightness for different lamps.</p>  <code>None</code>     <p>Returns:</p>    Type Description       <p>The output of the command</p>"},{"location":"reference/#pyradiance.load_views","title":"<code>load_views(file)</code>","text":"<p>Load views from a file. One view per line.</p> <p>Parameters:</p>    Name Type Description Default     <code>file</code>  <code>Union[str, Path]</code>  <p>A file path to a view file.</p>  required     <p>Returns:</p>    Type Description      <code>List[View]</code>  <p>A view object.</p>"},{"location":"reference/#pyradiance.mgf2rad","title":"<code>mgf2rad(*inp, matfile=None, mult=None, dist=None)</code>","text":"<p>Convert Materials and Geometry Format file to RADIANCE description.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>Path to MGF file</p>  <code>()</code>    <code>matfile</code>   <p>Path to material file where the translated materials will be written.</p>  <code>None</code>    <code>mult</code>   <p>multiplier for all the emission values</p>  <code>None</code>    <code>dist</code>   <p>glow distance (in meters) for all emitting surfaces.</p>  <code>None</code>     <p>Returns:</p>    Type Description       <p>The output of the command</p>"},{"location":"reference/#pyradiance.mkillum","title":"<code>mkillum(inp, octree, nproc=1, params=None)</code>","text":"<p>Compute illum sources for a RADIANCE scene</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>bytes</code>  <p>input file content as bytes</p>  required    <code>octree</code>  <code>Union[str, Path]</code>  <p>octree file</p>  required    <code>nproc</code>  <code>int</code>  <p>number of processes</p>  <code>1</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>additional parameters</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>Output of mkillum in bytes</p>"},{"location":"reference/#pyradiance.obj2rad","title":"<code>obj2rad(inp, quallist=False, flatten=False, mapfile=None, objname=None)</code>","text":"<p>Convert Wavefront .OBJ file to RADIANCE description.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>Union[bytes, str, Path]</code>  <p>Path to OBJ file</p>  required    <code>quallist</code>  <code>bool</code>  <p>Produce a list of qualifiers from which to construct a mapping for the given .OBJ file.</p>  <code>False</code>    <code>flatten</code>  <code>bool</code>  <p>Flatten all faces, effectively ignoring vertex normal information.</p>  <code>False</code>    <code>mapfile</code>  <code>Optional[str]</code>  <p>Mapping rules files for assigning material names for the surfaces.</p>  <code>None</code>    <code>objname</code>  <code>Optional[str]</code>  <p>Specify the name of this object, though it will be overriden by any \"o\" statements in the input file.  If this option is absent, and there are no \"o\" statements, obj2rad will attempt to name surfaces based on their group associations.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>The converted RADIANCE scene description in bytes</p>"},{"location":"reference/#pyradiance.oconv","title":"<code>oconv(*paths, warning=True, stdin=None, frozen=False, octree=None)</code>","text":"<p>Run Radiance oconv tool to build an octree.</p> <p>Parameters:</p>    Name Type Description Default     <code>paths</code>   <p>list of Radiance files</p>  <code>()</code>    <code>warning</code>   <p>if False, warnings will be suppressed</p>  <code>True</code>    <code>stdin</code>   <p>if not None, stdin will be used</p>  <code>None</code>    <code>frozen</code>  <code>bool</code>  <p>if True, the octree will be frozen</p>  <code>False</code>    <code>octree</code>   <p>if provided, the resulting octree incorporate existing one</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of oconv</p>"},{"location":"reference/#pyradiance.pabopto2bsdf","title":"<code>pabopto2bsdf(*inp, nproc=1, symmetry=None, angle=None, reverse=False)</code>","text":"<p>Convert BSDF measurements to a scattering interpolant representation.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>pab-opto Mountain files, need two or more.</p>  <code>()</code>    <code>nproc</code>  <code>int</code>  <p>number of processors to use.</p>  <code>1</code>    <code>symmetry</code>  <code>Optional[str]</code>  <p>BSDF symmetry, which is one of \"isotropic\", \"quadrilateral\", \"bilateral\", \"up\", or \"anisotropic\".  Any of these may be abbreviated with as little as a single letter, and case is ignored.</p>  <code>None</code>    <code>angle</code>  <code>Optional[Union[float, str]]</code>  <p>cull scattered measurements that are nearer to grazing than the given angle in degrees.  If the word \"auto\" (which can be abbreviated as 'a' or 'A') is given instead of an angle, then the near-grazing angle will be determined by the lowest incident angle measurement present in the input data.  This is sometimes necessary to eliminate noise and edge effects that some measurements exhibit near grazing.</p>  <code>None</code>    <code>reverse</code>   <p>reverses the assumed sample orientation front-to-back, and is discussed below under the \"#intheta\" header entry.</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>SIR data in bytes</p>"},{"location":"reference/#pyradiance.parse_primitive","title":"<code>parse_primitive(pstr)</code>","text":"<p>Parse Radiance primitives inside a file path into a list of dictionary.</p> <p>Parameters:</p>    Name Type Description Default     <code>pstr</code>  <code>str</code>  <p>A string of Radiance primitives.</p>  required     <p>Returns:</p>    Type Description      <code>List[Primitive]</code>  <p>list of primitives</p>"},{"location":"reference/#pyradiance.pcond","title":"<code>pcond(hdr, human=False, acuity=False, veiling=False, sense=False, closs=False, center_weighted=False, linear=False, fixfrac=0.0, fixpoints=None, histo='', expval='', ldmax=100.0, lddyn=100.0, primaries=None, macbeth='', mapfile='')</code>","text":"<p>Condition a Radiance picture.</p> <p>Parameters:</p>    Name Type Description Default     <code>hdr</code>  <code>Path</code>  <p>input hdr</p>  required    <code>human</code>  <code>bool</code>  <p>Mimic human visual response. This is the same as turning on all acuity, veiling, sensitivity, and color loss.</p>  <code>False</code>    <code>acuity</code>  <code>bool</code>  <p>Defocus darker region.</p>  <code>False</code>    <code>veiling</code>  <code>bool</code>  <p>Add veiling glare.</p>  <code>False</code>    <code>sense</code>  <code>bool</code>  <p>Use human contrast sensitivity, simulating eye internal scattering.</p>  <code>False</code>    <code>center_weighted</code>  <code>bool</code>  <p>Use center-weighted average for acuity and veiling.</p>  <code>False</code>    <code>linear</code>  <code>bool</code>  <p>Use a linear reponse function instead of the standard dynamic range compression. This preseves the extremas.</p>  <code>False</code>    <code>fixfrac</code>  <code>float</code>  <p>Fixation fraction for acuity and veiling.</p>  <code>0.0</code>    <code>histo</code>  <code>str</code>  <p>Histogram file for acuity and veiling.</p>  <code>''</code>    <code>expval</code>  <code>str</code>  <p>Exposure value for acuity and veiling.</p>  <code>''</code>    <code>ldmax</code>  <code>float</code>  <p>Maximum luminance for acuity and veiling.</p>  <code>100.0</code>    <code>lddyn</code>  <code>float</code>  <p>Luminance dynamic range for acuity and veiling.</p>  <code>100.0</code>    <code>primaries</code>  <code>Optional[List[float]]</code>  <p>Color primaries for color loss.</p>  <code>None</code>    <code>macbeth</code>  <code>str</code>  <p>Macbeth chart file for color loss.</p>  <code>''</code>    <code>mapfile</code>  <code>str</code>  <p>Color map file for color loss.</p>  <code>''</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of pcond</p>"},{"location":"reference/#pyradiance.pfilt","title":"<code>pfilt(image, xres=None, yres=None, pixel_aspect=0, pa_correct=False, exposure=0, lamp=None, lampdat=None, one_pass=False, gaussian_filter_radius=None, limitfrac=None, hot_threshold=100, star_points=0, star_spread=0.0001, average_hot=False)</code>","text":"<p>filter a Radiance picture. By default, it uses two passes on the input, using a box filter.</p> <p>Parameters:</p>    Name Type Description Default     <code>image</code>  <code>Union[str, Path, bytes]</code>  <p>input image</p>  required    <code>xres</code>  <code>Optional[str]</code>  <p>horizontal resolution</p>  <code>None</code>    <code>yres</code>  <code>Optional[str]</code>  <p>vertical resolution</p>  <code>None</code>    <code>pixel_aspect</code>  <code>float</code>  <p>pixel aspect ratio</p>  <code>0</code>    <code>exposure</code>  <code>Optional[float]</code>  <p>exposure value</p>  <code>0</code>    <code>lamp</code>  <code>Optional[str]</code>  <p>lamp file</p>  <code>None</code>    <code>lampdat</code>  <code>Optional[str]</code>  <p>lamp data file</p>  <code>None</code>    <code>one_pass</code>  <code>bool</code>  <p>use one pass filter</p>  <code>False</code>    <code>gaussian_filter_radius</code>  <code>Optional[float]</code>  <p>gaussian filter radius</p>  <code>None</code>    <code>limitfrac</code>  <code>Optional[float]</code>  <p>limit fraction</p>  <code>None</code>    <code>hot_threshold</code>  <code>float</code>  <p>Set intensity considered 'hot', default 100 watts/sr/m2</p>  <code>100</code>    <code>star_points</code>  <code>int</code>  <p>Number of points on a start pattern.</p>  <code>0</code>    <code>star_spread</code>  <code>float</code>  <p>star pattern spread</p>  <code>0.0001</code>    <code>average_hot</code>  <code>bool</code>  <p>average hot spots</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of pfilt</p>"},{"location":"reference/#pyradiance.pkgbsdf","title":"<code>pkgbsdf(*xml, frozen=False, stdout=False)</code>","text":"<p>Pacakge BSDFs provided as XML for Radiance.</p> <p>Parameters:</p>    Name Type Description Default     <code>xml</code>  <code>Union[str, Path]</code>  <p>Path to XML files</p>  <code>()</code>    <code>frozen</code>  <code>bool</code>  <p>produce frozen octree instance for any detail geometry.</p>  <code>False</code>    <code>stdout</code>  <code>bool</code>  <p>print the output to stdout, only works for a single XML input.</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The output of the command</p>"},{"location":"reference/#pyradiance.pvalue","title":"<code>pvalue(pic, unique=False, original=False, header=True, resstr=True, skip=0, exposure=0, gamma=1.0, dataonly=False, outform='', reverse_rgb=False, interleaving=True, brightness=False, outprimary=None)</code>","text":"<p>convert RADIANCE picture to/from alternate formats Pvalue converts the pixels of a RADIANCE picture to or from another format. In the default mode, pixels are sent to the standard output, one per line, in the following ascii format: xpos ypos red  green     blue</p> <p>Parameters:</p>    Name Type Description Default     <code>pic</code>  <code>Union[Path, str, bytes]</code>  <p>hdr file path. Either path or stdin is used, path takes precedence.</p>  required    <code>unique</code>  <code>bool</code>  <p>if True, only unique values will be returned</p>  <code>False</code>    <code>original</code>  <code>bool</code>  <p>if True, print original values, before exposure compensation</p>  <code>False</code>    <code>header</code>  <code>bool</code>  <p>if True, header will be returned</p>  <code>True</code>    <code>resstr</code>  <code>bool</code>  <p>if True, resolution string will be returned</p>  <code>True</code>    <code>skip</code>  <code>int</code>  <p>number of bytes to skip</p>  <code>0</code>    <code>exposure</code>  <code>int</code>  <p>exposure value</p>  <code>0</code>    <code>gamma</code>  <code>float</code>  <p>gamma value</p>  <code>1.0</code>    <code>dataonly</code>  <code>bool</code>  <p>if True, only data will be returned</p>  <code>False</code>    <code>outform</code>  <code>str</code>  <p>output data format</p>  <code>''</code>    <code>reverse_rgb</code>  <code>bool</code>  <p>if True, RGB values will be reversed</p>  <code>False</code>    <code>interleaving</code>  <code>bool</code>  <p>if True, interleaving will be used</p>  <code>True</code>    <code>brightness</code>  <code>bool</code>  <p>if True, only brightness will be returned</p>  <code>False</code>    <code>outprimary</code>  <code>Optional[str]</code>  <p>output color primaries</p>  <code>None</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of pvalue</p>"},{"location":"reference/#pyradiance.pvaluer","title":"<code>pvaluer(pic, xres=None, yres=None, inpformat='a', resstr=True, dataonly=False, header=False, primaries=None, pxyz=False)</code>","text":"<p>Run Radiance pvalue tools reverse mode: constructing a image from pixel values.</p> <p>Parameters:</p>    Name Type Description Default     <code>pic</code>  <code>Union[Path, str, bytes]</code>  <p>Path to Radiance picture file or bytes of the picture file.</p>  required    <code>xres</code>  <code>Optional[int]</code>  <p>Number of columns in the picture file.</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>Number of rows in the picture file.</p>  <code>None</code>    <code>inpformat</code>  <code>str</code>  <p>Radiance picture file format. Default is \"a\" for ascii.</p>  <code>'a'</code>    <code>header</code>  <code>bool</code>  <p>Set to True if the picture file has a header. Default is False.</p>  <code>False</code>    <code>primaries</code>  <code>Optional[List[float]]</code>  <p>List of primaries for XYZ calculation. Default is None.</p>  <code>None</code>    <code>pxyz</code>  <code>bool</code>  <p>Set to True to calculate XYZ values. Default is False.</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>Bytes of the pvalue output (Radiance .</p>"},{"location":"reference/#pyradiance.rcode_depth","title":"<code>rcode_depth(inp, ref_depth='1.0', inheader=True, outheader=True, inresolution=True, outresolution=True, xres=None, yres=None, inform='a', outform='a', decode=False, compute_intersection=False, per_point=False, depth_file=None, flush=False)</code>","text":"<p>Encode/decode 16-bit depth map.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>Union[str, Path, bytes]</code>  <p>input file or bytes</p>  required    <code>ref_depth</code>  <code>str</code>  <p>reference distance, can be follow by /unit.</p>  <code>'1.0'</code>    <code>inheader</code>  <code>bool</code>  <p>Set to False to not expect header on input</p>  <code>True</code>    <code>outheader</code>  <code>bool</code>  <p>Set to False to not include header on output</p>  <code>True</code>    <code>inresolution</code>  <code>bool</code>  <p>Set to False to not expect resolution on input</p>  <code>True</code>    <code>outresolution</code>  <code>bool</code>  <p>Set to False to not include resolution on output</p>  <code>True</code>    <code>xres</code>  <code>Optional[int]</code>  <p>x resolution</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>y resolution</p>  <code>None</code>    <code>inform</code>  <code>str</code>  <p>input format</p>  <code>'a'</code>    <code>outform</code>  <code>str</code>  <p>output format when decoding</p>  <code>'a'</code>    <code>decode</code>  <code>bool</code>  <p>Set to True to decode instead</p>  <code>False</code>    <code>compute_intersection</code>  <code>bool</code>  <p>Set to True to compute intersection instead</p>  <code>False</code>    <code>per_point</code>  <code>bool</code>  <p>Set to True to compute per point instead of per pixel</p>  <code>False</code>    <code>depth_file</code>  <code>Optional[str]</code>  <p>depth file</p>  <code>None</code>    <code>flush</code>  <code>bool</code>  <p>Set to True to flush output</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of rcode_depth</p>"},{"location":"reference/#pyradiance.rcode_norm","title":"<code>rcode_norm(inp, inheader=True, outheader=True, inresolution=True, outresolution=True, xres=None, yres=None, inform='a', outform='a', decode=False, per_point=False, norm_file=None, flush=False)</code>","text":"<p>Encode/decode 32-bit surface normal map.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>input file or bytes</p>  required    <code>inheader</code>  <code>bool</code>  <p>Set to False to not expect header on input</p>  <code>True</code>    <code>outheader</code>  <code>bool</code>  <p>Set to False to not include header on output</p>  <code>True</code>    <code>inresolution</code>  <code>bool</code>  <p>Set to False to not expect resolution on input</p>  <code>True</code>    <code>outresolution</code>  <code>bool</code>  <p>Set to False to not include resolution on output</p>  <code>True</code>    <code>xres</code>  <code>Optional[int]</code>  <p>x resolution</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>y resolution</p>  <code>None</code>    <code>inform</code>  <code>str</code>  <p>input format</p>  <code>'a'</code>    <code>outform</code>  <code>str</code>  <p>output format when decoding</p>  <code>'a'</code>    <code>decode</code>  <code>bool</code>  <p>Set to True to decode instead</p>  <code>False</code>    <code>per_point</code>  <code>bool</code>  <p>Set to True to compute per point instead of per pixel</p>  <code>False</code>    <code>flush</code>  <code>bool</code>  <p>Set to True to flush output</p>  <code>False</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of rcode_norm</p>"},{"location":"reference/#pyradiance.rcontrib","title":"<code>rcontrib(inp, octree, modifiers, nproc=1, yres=None, inform=None, outform=None, report=0, params=None)</code>","text":"<p>Run rcontrib command.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>bytes</code>  <p>A bytes object.</p>  required    <code>octree</code>  <code>Union[Path, str]</code>  <p>A path to octree file.</p>  required    <code>modifiers</code>  <code>Sequence[RcModifier]</code>  <p>A list of RcModifier objects.</p>  required    <code>nproc</code>  <code>int</code>  <p>Number of processes.</p>  <code>1</code>    <code>yres</code>  <code>Optional[int]</code>  <p>Y resolution.</p>  <code>None</code>    <code>inform</code>  <code>Optional[str]</code>  <p>Input format.</p>  <code>None</code>    <code>outform</code>  <code>Optional[str]</code>  <p>Output format.</p>  <code>None</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>A list of additional parameters.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A bytes object.</p>"},{"location":"reference/#pyradiance.render","title":"<code>render(scene, view=None, quality='Medium', variability='Medium', detail='Medium', nproc=1, resolution=None, ambbounce=None, ambcache=True, params=None)</code>","text":"<p>Render a scene.</p> <p>Parameters:</p>    Name Type Description Default     <code>scene</code>   <p>Scene object.</p>  required    <code>quality</code>  <code>str</code>  <p>Quality level.</p>  <code>'Medium'</code>    <code>variability</code>  <code>str</code>  <p>Variability level.</p>  <code>'Medium'</code>    <code>detail</code>  <code>str</code>  <p>Detail level.</p>  <code>'Medium'</code>    <code>nproc</code>  <code>int</code>  <p>Number of processes to use.</p>  <code>1</code>    <code>ambbounce</code>  <code>Optional[int]</code>  <p>Number of ambient bounces.</p>  <code>None</code>    <code>ambcache</code>  <code>bool</code>  <p>Use ambient cache.</p>  <code>True</code>    <code>params</code>  <code>Optional[SamplingParameters]</code>  <p>Sampling parameters.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>tuple[bytes, int, int]: output of render, width, height</p>"},{"location":"reference/#pyradiance.rfluxmtx","title":"<code>rfluxmtx(receiver, surface=None, rays=None, params=None, octree=None, scene=None)</code>","text":"<p>Run rfluxmtx command.</p> <p>Parameters:</p>    Name Type Description Default     <code>scene</code>  <code>Optional[Sequence[Union[Path, str]]]</code>  <p>A Scene object.</p>  <code>None</code>    <code>sender</code>   <p>A Sender.</p>  required    <code>receiver</code>  <code>Union[str, Path]</code>  <p>A Radiance SensorGrid.</p>  required    <code>option</code>   <p>Radiance parameters for rfluxmtx command as a list of strings.</p>  required     <p>Sender: stdin, polygon Receiver: surface with -o</p>"},{"location":"reference/#pyradiance.rlam","title":"<code>rlam(*inputs)</code>","text":"<p>Laminate records from multiple files.</p> <p>Parameters:</p>    Name Type Description Default     <code>inputs</code>   <p>list of input files or bytes. There can</p>  <code>()</code>     <p>Returns:</p>    Name Type Description     <code>bytes</code>  <code>bytes</code>  <p>output of rlam</p>"},{"location":"reference/#pyradiance.rmtxop","title":"<code>rmtxop(inp, outform='a', transpose=False, scale=None, transform=None, reflectance=None)</code>","text":"<p>Run rmtxop command.</p>"},{"location":"reference/#pyradiance.robjutil","title":"<code>robjutil(inp, radout=False, verbose=False, remove_texture_coordinates=False, remove_surface_normal=False, remove_surface_by_modifier=None, keep_surface_by_modifier=None, remove_surface_by_group=None, keep_surface_by_group=None, epsilon=None, triangulate=False, transform=None)</code>","text":"<p>Operate on Wavefront .OBJ file</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>  <code>Union[str, Path]</code>  <p>Input .OBJ file path</p>  required    <code>radout</code>  <code>bool</code>  <p>Output RADIANCE scene description</p>  <code>False</code>    <code>verbose</code>  <code>bool</code>  <p>Set to True to turn on verbosity</p>  <code>False</code>    <code>remove_texture_coordinates</code>  <code>bool</code>  <p>Remove texture coordinates from the output</p>  <code>False</code>    <code>remove_surface_normal</code>  <code>bool</code>  <p>Remove surface normal from the output</p>  <code>False</code>    <code>remove_surface_by_modifier</code>  <code>Optional[Sequence[str]]</code>  <p>Remove surfaces by modifier, mutually exclusive with keep_surface_by_modifier</p>  <code>None</code>    <code>keep_surface_by_modifier</code>  <code>Optional[Sequence[str]]</code>  <p>Keep surfaces by modifier, mutually exclusive with remove_surface_by_modifier</p>  <code>None</code>    <code>remove_surface_by_group</code>  <code>Optional[Sequence[str]]</code>  <p>Remove surfaces by group/object, mutually exclusive with keep_surface_by_group</p>  <code>None</code>    <code>keep_surface_by_group</code>  <code>Optional[Sequence[str]]</code>  <p>Keep surfaces by group/object, mutually exclusive with remove_surface_by_group</p>  <code>None</code>    <code>epsilon</code>  <code>Optional[float]</code>  <p>Coalesce vertices that are within the given epsilon</p>  <code>None</code>    <code>triangulate</code>  <code>bool</code>  <p>Turns all faces with 4 or more sides into triangles</p>  <code>False</code>    <code>transform</code>  <code>Optional[str]</code>  <p>Transform the input, using xform CLI syntax.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>The output of the command</p>"},{"location":"reference/#pyradiance.rpict","title":"<code>rpict(view, octree, xres=None, yres=None, report=0, report_file=None, params=None)</code>","text":"<p>Get rpict command.</p> <p>Parameters:</p>    Name Type Description Default     <code>view</code>  <code>Sequence[str]</code>  <p>A list of view parameters in strings.</p>  required    <code>octree</code>  <code>Union[Path, str]</code>  <p>A path to octree file.</p>  required    <code>xres</code>  <code>Optional[int]</code>  <p>X resolution.</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>Y resolution.</p>  <code>None</code>    <code>report</code>  <code>float</code>  <p>Report.</p>  <code>0</code>    <code>report_file</code>  <code>Optional[Path]</code>  <p>Report file.</p>  <code>None</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>A list of additional parameters.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A bytes object.</p>"},{"location":"reference/#pyradiance.rsensor","title":"<code>rsensor(sensor, sensor_view=None, direct_ray=None, ray_count=None, octree=None, nproc=1, params=None)</code>","text":"<p>Compute sensor signal from a RADIANCE scene</p> <p>Parameters:</p>    Name Type Description Default     <code>sensor</code>  <code>Sequence[Union[str, Path]]</code>  <p>Sensor file</p>  required    <code>sensor_view</code>  <code>Optional[Sequence[Union[str, Path]]]</code>  <p>Sensor view file</p>  <code>None</code>    <code>direct_ray</code>  <code>Optional[Sequence[int]]</code>  <p>The number of rays sent to each light source per sensor</p>  <code>None</code>    <code>ray_count</code>  <code>Optional[Sequence[int]]</code>  <p>The number of ray samples sent at random</p>  <code>None</code>    <code>octree</code>  <code>Optional[Union[str, Path]]</code>  <p>Octree file</p>  <code>None</code>    <code>nproc</code>  <code>int</code>  <p>Number of processors to use</p>  <code>1</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>Additional parameters for rsensor command</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>Output of rsensor command</p>"},{"location":"reference/#pyradiance.rtpict","title":"<code>rtpict(view, octree, nproc=1, outform=None, outdir=None, ref_depth=None, xres=None, yres=None, params=None)</code>","text":"<p>Run rtpict command.</p> <p>Parameters:</p>    Name Type Description Default     <code>view</code>  <code>View</code>  <p>A View object.</p>  required    <code>octree</code>  <code>Union[str, Path]</code>  <p>Path to octree file.</p>  required    <code>nproc</code>  <code>int</code>  <p>Number of processors to use.</p>  <code>1</code>    <code>outform</code>  <code>Optional[str]</code>  <p>Output format. Default is \"i\".</p>  <code>None</code>    <code>outdir</code>  <code>Optional[str]</code>  <p>Output directory. Default is current directory.</p>  <code>None</code>    <code>ref_depth</code>  <code>Optional[str]</code>  <p>Maximum number of reflections. Default is 5.</p>  <code>None</code>    <code>xres</code>  <code>Optional[int]</code>  <p>Horizontal resolution. Default is 512.</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>Vertical resolution. Default is 512.</p>  <code>None</code>    <code>params</code>  <code>Optional[Sequence[str]]</code>  <p>Radiance parameters for rtpict command as a list of strings.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>Rendered image as output or None if output to directory</p>"},{"location":"reference/#pyradiance.rtrace","title":"<code>rtrace(rays, octree, header=True, inform='a', outform='a', irradiance=False, irradiance_lambertian=False, outspec=None, trace_exclude='', trace_include='', trace_exclude_file=None, trace_include_file=None, uncorrelated=False, xres=None, yres=None, nproc=None, params=None, report=False, version=False)</code>","text":"<p>Run rtrace.</p> <p>Parameters:</p>    Name Type Description Default     <code>rays</code>  <code>bytes</code>  <p>A string of bytes representing the input rays.</p>  required    <code>octree</code>  <code>Union[Path, str]</code>  <p>Path to octree file.</p>  required    <code>header</code>  <code>bool</code>  <p>A boolean to indicate if the header should be included in the output.</p>  <code>True</code>    <code>inform</code>  <code>str</code>  <p>Input format. Default is 'a'.</p>  <code>'a'</code>    <code>outform</code>  <code>str</code>  <p>Output format. Default is 'a'.</p>  <code>'a'</code>    <code>irradiance</code>  <code>bool</code>  <p>A boolean to indicate if irradiance should be calculated.</p>  <code>False</code>    <code>irradiance_lambertian</code>  <code>bool</code>  <p>A boolean to indicate if irradiance should be calculated using Lambertian assumption.</p>  <code>False</code>    <code>outspec</code>  <code>Optional[str]</code>  <p>Output specification. Default is None.</p>  <code>None</code>    <code>trace_exclude</code>  <code>str</code>  <p>A string of space separated material names to exclude from the trace.</p>  <code>''</code>    <code>trace_include</code>  <code>str</code>  <p>A string of space separated material names to include in the trace.</p>  <code>''</code>    <code>trace_exclude_file</code>  <code>Optional[Union[str, Path]]</code>  <p>Path to a file containing material names to exclude from the trace.</p>  <code>None</code>    <code>trace_include_file</code>  <code>Optional[Union[str, Path]]</code>  <p>Path to a file containing material names to include in the trace.</p>  <code>None</code>    <code>uncorrelated</code>  <code>bool</code>  <p>A boolean to indicate if uncorrelated sampling should be used.</p>  <code>False</code>    <code>xres</code>  <code>Optional[int]</code>  <p>X resolution of the output image.</p>  <code>None</code>    <code>yres</code>  <code>Optional[int]</code>  <p>Y resolution of the output image.</p>  <code>None</code>    <code>nproc</code>  <code>Optional[int]</code>  <p>Number of processors to use.</p>  <code>None</code>    <code>options</code>   <p>A SamplingParameters object.</p>  required     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A string of bytes representing the output of rtrace.</p>"},{"location":"reference/#pyradiance.vwrays","title":"<code>vwrays(pixpos=None, unbuf=False, outform='a', ray_count=1, pixel_jitter=0, pixel_diameter=0, pixel_aspect=1, xres=512, yres=512, dimensions=False, view=None, pic=None, zbuf=None)</code>","text":"<p>vwrays.</p>"},{"location":"reference/#pyradiance.wrapbsdf","title":"<code>wrapbsdf(inp=None, enforce_window=False, comment=None, correct_solid_angle=False, basis=None, tf=None, tb=None, rf=None, rb=None, spectr=None, unlink=False, unit=None, geometry=None, **kwargs)</code>","text":"<p>Wrap BSDF.</p> <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>Input file. Default is stdin.</p>  <code>None</code>    <code>enforce_window</code>   <p>Enforce window convention. Default is False.</p>  <code>False</code>    <code>comment</code>  <code>Optional[str]</code>  <p>Comment. Default is None.</p>  <code>None</code>    <code>correct_solid_angle</code>   <p>Correct solid angle. Default is False.</p>  <code>False</code>    <code>basis</code>  <code>Optional[str]</code>  <p>Basis. Default is None.</p>  <code>None</code>    <code>tf</code>  <code>Optional[Union[str, Path]]</code>  <p>Front transmittance. Default is None.</p>  <code>None</code>    <code>tb</code>  <code>Optional[Union[str, Path]]</code>  <p>Back transmittance. Default is None.</p>  <code>None</code>    <code>rf</code>  <code>Optional[Union[str, Path]]</code>  <p>Front reflectance. Default is None.</p>  <code>None</code>    <code>rb</code>  <code>Optional[Union[str, Path]]</code>  <p>Back reflectance. Default is None.</p>  <code>None</code>    <code>spectr</code>  <code>Optional[str]</code>  <p>Spectral data. Default is None.</p>  <code>None</code>    <code>unlink</code>  <code>bool</code>  <p>Unlink. Default is False.</p>  <code>False</code>    <code>unit</code>   <p>Unit. Default is None.</p>  <code>None</code>    <code>geometry</code>   <p>Geometry. Default is None.</p>  <code>None</code>    <code>**kwargs</code>   <p>Additional arguments for Window tags such as n, m, t...</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>Wrapped BSDF.</p>"},{"location":"reference/#pyradiance.xform","title":"<code>xform(inp, translate=None, expand_cmd=True, iprefix=None, modifier=None, invert=False, rotatex=None, rotatey=None, rotatez=None, scale=None, mirrorx=False, mirrory=False, mirrorz=False)</code>","text":"<p>Transform a RADIANCE scene description</p>  Notes <p>Iterate and arrays are not supported.</p>  <p>Parameters:</p>    Name Type Description Default     <code>inp</code>   <p>Input file or string</p>  required    <code>translate</code>  <code>Optional[Tuple[float, float, float]]</code>  <p>Translation vector</p>  <code>None</code>    <code>expand_cmd</code>  <code>bool</code>  <p>Set to True to expand command</p>  <code>True</code>    <code>iprefix</code>  <code>Optional[str]</code>  <p>Prefix identifier</p>  <code>None</code>    <code>mprefix</code>   <p>Set surface modifier to this name</p>  required    <code>invert</code>  <code>bool</code>  <p>Invert surface normal</p>  <code>False</code>    <code>rotatex</code>  <code>Optional[float]</code>  <p>Rotate the scene degrees about the x axis. A positive rotation corresponds to</p>  <code>None</code>    <code>rotatey</code>  <code>Optional[float]</code>  <p>Rotate the scene degrees about the y axis.</p>  <code>None</code>    <code>rotatez</code>  <code>Optional[float]</code>  <p>Rotate the scene degrees about the z axis.</p>  <code>None</code>    <code>scale</code>  <code>Optional[float]</code>  <p>Scale the scene by this factor</p>  <code>None</code>    <code>mirrorx</code>  <code>bool</code>  <p>Mirror the scene about the yz plane.</p>  <code>False</code>    <code>mirrory</code>  <code>bool</code>  <p>Mirror the scene about the xz plane.</p>  <code>False</code>    <code>mirrorz</code>  <code>bool</code>  <p>Mirror the scene about the xy plane.</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>The transformed scene description in bytes</p>"},{"location":"tutorials/","title":"Quickstart","text":""},{"location":"tutorials/#importing-pyradiance","title":"Importing pyradiance","text":"<p>After installing pyradiance, it can be imported as follows: <pre><code>import pyradiance as pr\n</code></pre> We use an alias <code>pr</code> here to improve code readability.</p>"},{"location":"tutorials/#creating-a-scene","title":"Creating a scene","text":"<p>Here we are using RADIANCE files created beforehand to create a scene object used for rendering.</p> <p>First, we instantiate a <code>Scene</code> object by giving it a name.</p> <p><pre><code>scene = pr.Scene(\"ascene\")\n</code></pre> Next, we start adding materials and surfaces to the scene from local directories. <pre><code>scene.add_material(\"Objects/materials.mat\")\nscene.add_surface(\"Objects/walls.rad\")\nscene.add_surface(\"Objects/ceiling.rad\")\nscene.add_surface(\"Objects/floor.rad\")\n</code></pre> Similar, we add our light sources: <pre><code>scene.add_source(\"Sources/sky.rad\")\n</code></pre> In order to render a image, we'd also need to define camera/view. Here, we are defining a view at (1, 1, 1.5), facing (1, 0, 0). We use default values for the rest of the view parameters. <pre><code>aview = pr.View(position=(1, 1.5, 1), direction=(1, 0, 0))\n</code></pre> Then, we add this view to our scene. <pre><code>scene.add_view(aview)\n</code></pre></p>  <p>Note</p> <p>Scene object here is only used for render() function. Regular RADIANCE functions such as rpict(),  rtrace(), rcontrib()  currently doesn't take <code>Scene</code> as input.  These 'raw' RADIANCE functions takes file paths as input instead, as they do in RADIANCE CLI.</p>"},{"location":"tutorials/#rendering-a-scene","title":"Rendering a scene","text":"<p>A scene can be rendering using the render() function. The <code>render()</code> function has a few optional arguments. RADIANCE, by default, uses zero ambient bounce, which we can overwrite by defining the <code>ambbounce</code> argument: <pre><code>image = pr.render(scene, ambbounce=1)\n</code></pre> The render function returns the generated <code>.hdr</code> image as bytes. </p>"},{"location":"tutorials/#visualizing-an-image","title":"Visualizing an image","text":"<p>We can visualize the image using popular computing and plotting library such as numpy and matplotlib.</p>"},{"location":"tutorials/#falscolor-image","title":"Falscolor image","text":"<p>Falsecolor-ing an image is a common practice in quantitative analysis. An falsecolor image maps the full range of an HDR image into a color scale. First, we convert our <code>image</code> into a numpy array. This is usually the first step before any analysis in Python, since most of the analysis and  visualization library recognize the <code>numpy.ndarray</code> object. We use pvalue() and  get_image_dimension() function for this step.  <pre><code>import numpy as np\nxres, yres = pr.get_image_dimensions(image)\npixels = pr.pvalue(image, header=False, outform='f', resstr=False)\niar = np.frombuffer(pixels, dtype=np.single).reshape(xres, yres, 3)\n</code></pre></p>  <p>Note</p> <p>Notice the <code>outform</code> argument in the <code>pvalue()</code> function and <code>dtype</code> argument in the <code>np.frombuffer()</code> function need to match.  In this case, both are indicating the output and input data format to be single precision float. We also need to remove header and resolution string from the pvalue output.</p>  <p>Now we have the image as numpy array, <code>iar</code>. The shape of this array is xres by yres by 3, where 3 represents the RGB channels. We are, however, usually interested in radiance or luminance values for each pixel. To do that we can weight the RGB channels to get our luminance values. This is trivial now with numpy array. <pre><code>luminance = iar[:, :, 0] * 47.4 + iar[:, :, 1] * 119.9 + iar[:, :, 2] * 11.6\n</code></pre> With the luminance values as another numpy array, we can use the matplotlib library to plot the image. <pre><code>import matplotlib.pyplot as plt\n\n# using a viridis color map\ncmap = plt.cm.viridis\n\n# setup a logrithm normalizer\nnorm = LogNorm()\n\nplt.axis(\"off\")\nfimage = cmap(norm(luminance))\nplt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), label=r\"$\\mathrm{cd/m^2}$\")\n</code></pre> </p>"},{"location":"tutorials/#tonemapping","title":"Tonemapping","text":"<p>We can use pcond() function to apply more advanced tonemapping  techniques, e.g., applying a human vision adaption. <code>pcond()</code> function, however, takes a image file as input, so we  need to write our <code>.hdr</code> image into a file before we can call <code>pcond()</code>. <pre><code>with open(\"raw.hdr\", \"wb\") as wtr:\n    wtr.write(image)\ntimage = pr.pcond(\"raw.hdr\", human=True)\n</code></pre> Next we can convert this tonemapped HDR into a numpy array and visualize it using matplotlib.  <pre><code>tpix = pr.pvalue(timage, header=False, resstr=False, outform='f')\ntiar = np.frombuffer(tpix, dtype=np.single).reshape(xres, yres, 3)\nplt.imshow(tiar*(1.0/2.2))\n</code></pre></p>  <p>Note</p> <p>Notice we apply a 2.2 gamma correction here.</p>"}]}