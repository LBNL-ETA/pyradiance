{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Pyradiance is a Python wrapper to the validated  RADIANCE ray-tracing system  that mimics closely the RADIANCE CLI. See Reference for a complete  list of supported RADIANCE functions.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pyradiance can be installed via pip from PyPI: <pre><code>pip install pyradiance\n</code></pre> This command will install also Radiance binaries and libraries files,  setting up the PATH environment. You don't need to install Radiance  separately. If you already have RADIANCE installed  in your system, pyradiance won't interfere with it either.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python &gt;= 3.8</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>For new users, here is a quickstart tutorial</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>This work was supported by the Assistant Secretary for Energy Efficiency and Renewable Energy, Building Technologies Program, of the U.S. Department of Energy, under Contract No. DE-AC02-05CH11231.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pyradiance","title":"<code>pyradiance</code>","text":"<p>pyradiance is a Python interface for Radiance. It is a collection of Python modules that provide a high level interface to Radiance. It is designed to make Radiance easier to use and accessible to Python user.</p>"},{"location":"reference/#pyradiance.Pcomb","title":"<code>Pcomb</code>","text":""},{"location":"reference/#pyradiance.Pcomb.__init__","title":"<code>__init__(xres=None, yres=None, inform='a', fout=True, header=False, expression=None, source=None)</code>","text":"<p>combine Radiance pictures and/or float matrices</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <p>list of PcombInput</p> required <code>xres</code> <code>None | int</code> <p>horizontal resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>vertical resolution</p> <code>None</code> <code>inform</code> <code>str</code> <p>input data format. Default is \"a\" for ascii.</p> <code>'a'</code> <code>fout</code> <code>bool</code> <p>if True, write output to file</p> <code>True</code> <code>header</code> <code>bool</code> <p>if True, write header</p> <code>False</code> <code>expression</code> <code>None | str</code> <p>expression</p> <code>None</code> <code>source</code> <code>None | str</code> <p>source</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <p>output of pcomb</p>"},{"location":"reference/#pyradiance.Primitive","title":"<code>Primitive</code>  <code>dataclass</code>","text":"<p>Radiance Primitive.</p> <p>Attributes one-to-one mapped from Radiance.</p> <p>Attributes:</p> Name Type Description <code>modifier</code> <code>str</code> <p>modifier, which primitive modifies this one</p> <code>ptype</code> <code>str</code> <p>primitive type</p> <code>identifier</code> <code>str</code> <p>identifier, name of this primitive</p> <code>sargs</code> <code>Sequence[str]</code> <p>string arguments</p> <code>fargs</code> <code>Sequence[float]</code> <p>real arguments</p>"},{"location":"reference/#pyradiance.RayParams","title":"<code>RayParams</code>","text":""},{"location":"reference/#pyradiance.RayParams.__module__","title":"<code>__module__ = 'pyradiance.rad_params'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pyradiance.RayParams.aa","title":"<code>aa</code>  <code>property</code>","text":"<p>ambient accuracy</p>"},{"location":"reference/#pyradiance.RayParams.ab","title":"<code>ab</code>  <code>property</code>","text":"<p>ambient bounce</p>"},{"location":"reference/#pyradiance.RayParams.ad","title":"<code>ad</code>  <code>property</code>","text":"<p>ambient division</p>"},{"location":"reference/#pyradiance.RayParams.af","title":"<code>af</code>  <code>property</code>","text":"<p>ambient file</p>"},{"location":"reference/#pyradiance.RayParams.ambincl","title":"<code>ambincl</code>  <code>property</code>","text":"<p>ambient inclusion/exclusion</p>"},{"location":"reference/#pyradiance.RayParams.amblist","title":"<code>amblist</code>  <code>property</code>","text":"<p>(self) -&gt; list</p>"},{"location":"reference/#pyradiance.RayParams.ar","title":"<code>ar</code>  <code>property</code>","text":"<p>ambient resolution</p>"},{"location":"reference/#pyradiance.RayParams.as","title":"<code>as</code>  <code>property</code>","text":"<p>ambient super sampling</p>"},{"location":"reference/#pyradiance.RayParams.av","title":"<code>av</code>  <code>property</code>","text":"<p>ambient values</p>"},{"location":"reference/#pyradiance.RayParams.aw","title":"<code>aw</code>  <code>property</code>","text":"<p>ambient weight</p>"},{"location":"reference/#pyradiance.RayParams.bv","title":"<code>bv</code>  <code>property</code>","text":"<p>source back side visibility</p>"},{"location":"reference/#pyradiance.RayParams.dc","title":"<code>dc</code>  <code>property</code>","text":"<p>direct certainty</p>"},{"location":"reference/#pyradiance.RayParams.dj","title":"<code>dj</code>  <code>property</code>","text":"<p>direct jitter</p>"},{"location":"reference/#pyradiance.RayParams.dp","title":"<code>dp</code>  <code>property</code>","text":"<p>virtual source pretesting</p>"},{"location":"reference/#pyradiance.RayParams.dr","title":"<code>dr</code>  <code>property</code>","text":"<p>direct relay</p>"},{"location":"reference/#pyradiance.RayParams.ds","title":"<code>ds</code>  <code>property</code>","text":"<p>source size aspect ratio</p>"},{"location":"reference/#pyradiance.RayParams.dt","title":"<code>dt</code>  <code>property</code>","text":"<p>direct threshold</p>"},{"location":"reference/#pyradiance.RayParams.dv","title":"<code>dv</code>  <code>property</code>","text":"<p>direct visibility</p>"},{"location":"reference/#pyradiance.RayParams.i","title":"<code>i</code>  <code>property</code>","text":"<p>do irradiance</p>"},{"location":"reference/#pyradiance.RayParams.lr","title":"<code>lr</code>  <code>property</code>","text":"<p>max depth</p>"},{"location":"reference/#pyradiance.RayParams.lw","title":"<code>lw</code>  <code>property</code>","text":"<p>minimum ray weight</p>"},{"location":"reference/#pyradiance.RayParams.ma","title":"<code>ma</code>  <code>property</code>","text":"<p>medium (mist) scattering albedo</p>"},{"location":"reference/#pyradiance.RayParams.me","title":"<code>me</code>  <code>property</code>","text":"<p>medium(mist) extinction coefficients</p>"},{"location":"reference/#pyradiance.RayParams.mg","title":"<code>mg</code>  <code>property</code>","text":"<p>medium (mist) eccentricity factor</p>"},{"location":"reference/#pyradiance.RayParams.ms","title":"<code>ms</code>  <code>property</code>","text":"<p>medium (mist) sampling distance</p>"},{"location":"reference/#pyradiance.RayParams.ss","title":"<code>ss</code>  <code>property</code>","text":"<p>specular jitter</p>"},{"location":"reference/#pyradiance.RayParams.st","title":"<code>st</code>  <code>property</code>","text":"<p>specular threshold</p>"},{"location":"reference/#pyradiance.RayParams.u","title":"<code>u</code>  <code>property</code>","text":"<p>random sampling</p>"},{"location":"reference/#pyradiance.RayParams.__init__","title":"<code>__init__(*args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"reference/#pyradiance.RayParams.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#pyradiance.Rcomb","title":"<code>Rcomb</code>","text":""},{"location":"reference/#pyradiance.Rcomb.__init__","title":"<code>__init__(transform=None, transform_all=None, source=None, expression=None, concat=None, outform=None, header=True, silent=False)</code>","text":"<p>Combine multiple rasters.</p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>None | str</code> <p>transform</p> <code>None</code> <code>transform_all</code> <code>None | str</code> <p>transform all</p> <code>None</code> <code>source</code> <code>None | str</code> <p>source</p> <code>None</code> <code>expression</code> <code>None | str</code> <p>expression</p> <code>None</code> <code>concat</code> <code>None | Sequence[str]</code> <p>concat</p> <code>None</code> <code>outform</code> <code>None | str</code> <p>output format</p> <code>None</code> <code>header</code> <code>bool</code> <p>include header</p> <code>True</code> <code>silent</code> <code>bool</code> <p>suppress output</p> <code>False</code>"},{"location":"reference/#pyradiance.Rcomb.add_input","title":"<code>add_input(input, transform=None, scale=None)</code>","text":"<p>Combine multiple rasters.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str | Path | bytes</code> <p>input can be file path or bytes</p> required <code>transform</code> <code>None | str</code> <p>transform string</p> <code>None</code> <code>scale</code> <code>None | Sequence[float]</code> <p>sequence of scaling factors</p> <code>None</code>"},{"location":"reference/#pyradiance.Resolu","title":"<code>Resolu</code>","text":""},{"location":"reference/#pyradiance.Resolu.__module__","title":"<code>__module__ = 'pyradiance.rad_params'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pyradiance.Resolu.rt","title":"<code>rt</code>  <code>property</code>","text":"<p>(self) -&gt; int</p>"},{"location":"reference/#pyradiance.Resolu.xr","title":"<code>xr</code>  <code>property</code>","text":"<p>(self) -&gt; int</p>"},{"location":"reference/#pyradiance.Resolu.yr","title":"<code>yr</code>  <code>property</code>","text":"<p>(self) -&gt; int</p>"},{"location":"reference/#pyradiance.Resolu.__init__","title":"<code>__init__()</code>  <code>method descriptor</code>","text":"<p>init(self) -&gt; None</p>"},{"location":"reference/#pyradiance.Resolu.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#pyradiance.Scene","title":"<code>Scene</code>","text":"<p>Radiance Scene.</p>"},{"location":"reference/#pyradiance.Scene.materials","title":"<code>materials</code>  <code>property</code>","text":"<p>Scene materials.</p>"},{"location":"reference/#pyradiance.Scene.octree","title":"<code>octree</code>  <code>property</code>","text":"<p>Scene id.</p>"},{"location":"reference/#pyradiance.Scene.sid","title":"<code>sid</code>  <code>property</code>","text":"<p>Scene id.</p>"},{"location":"reference/#pyradiance.Scene.sources","title":"<code>sources</code>  <code>property</code>","text":"<p>Scene sources.</p>"},{"location":"reference/#pyradiance.Scene.surfaces","title":"<code>surfaces</code>  <code>property</code>","text":"<p>Scene surfaces.</p>"},{"location":"reference/#pyradiance.Scene.__init__","title":"<code>__init__(sid, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>sid</code> <code>str</code> <p>scene id</p> required"},{"location":"reference/#pyradiance.Scene.add_material","title":"<code>add_material(material)</code>","text":"<p>Add material to the scene. Args:     material: material to be added</p>"},{"location":"reference/#pyradiance.Scene.add_sensor","title":"<code>add_sensor(sensor)</code>","text":"<p>Add sensor to the scene. Args:     sensor: sensor to be added</p>"},{"location":"reference/#pyradiance.Scene.add_source","title":"<code>add_source(source)</code>","text":"<p>Add source to the scene. Args:     source: source to be added</p>"},{"location":"reference/#pyradiance.Scene.add_surface","title":"<code>add_surface(surface)</code>","text":"<p>Add surface to the scene. Args:     surface: surface to be added</p>"},{"location":"reference/#pyradiance.Scene.add_view","title":"<code>add_view(view)</code>","text":"<p>Add view to the scene. Args:     view: view to be added</p>"},{"location":"reference/#pyradiance.Scene.build","title":"<code>build()</code>","text":"<p>Build an octree, as {sid}.oct in the current directory. Will not build if scene has not changed since last build.</p>"},{"location":"reference/#pyradiance.Scene.remove_material","title":"<code>remove_material(material)</code>","text":"<p>Remove material from the scene. Args:     material: material to be removed</p>"},{"location":"reference/#pyradiance.Scene.remove_source","title":"<code>remove_source(source)</code>","text":"<p>Remove source from the scene. Args:     source: source to be removed</p>"},{"location":"reference/#pyradiance.Scene.remove_surface","title":"<code>remove_surface(surface)</code>","text":"<p>Remove surface from the scene. Args:     surface: surface to be removed</p>"},{"location":"reference/#pyradiance.View","title":"<code>View</code>","text":""},{"location":"reference/#pyradiance.View.__module__","title":"<code>__module__ = 'pyradiance.rad_params'</code>  <code>class</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#pyradiance.View.hn2","title":"<code>hn2</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"reference/#pyradiance.View.hoff","title":"<code>hoff</code>  <code>property</code>","text":"<p>View horizontal offset</p>"},{"location":"reference/#pyradiance.View.horiz","title":"<code>horiz</code>  <code>property</code>","text":"<p>View horizontal size</p>"},{"location":"reference/#pyradiance.View.hvec","title":"<code>hvec</code>  <code>property</code>","text":"<p>(self) -&gt; tuple</p>"},{"location":"reference/#pyradiance.View.type","title":"<code>type</code>  <code>property</code>","text":"<p>View types: 'v': perspective, 'l': parallel, 'c': cylindrical panorma, 'h': hemispherical fisheye, 'a': angular fisheye, 's': planispherical fisheye</p>"},{"location":"reference/#pyradiance.View.vaft","title":"<code>vaft</code>  <code>property</code>","text":"<p>View aft clipping plane</p>"},{"location":"reference/#pyradiance.View.vdir","title":"<code>vdir</code>  <code>property</code>","text":"<p>View direction: x, y, z</p>"},{"location":"reference/#pyradiance.View.vdist","title":"<code>vdist</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"reference/#pyradiance.View.vert","title":"<code>vert</code>  <code>property</code>","text":"<p>View vertical size</p>"},{"location":"reference/#pyradiance.View.vfore","title":"<code>vfore</code>  <code>property</code>","text":"<p>View fore clipping plane</p>"},{"location":"reference/#pyradiance.View.vn2","title":"<code>vn2</code>  <code>property</code>","text":"<p>(self) -&gt; float</p>"},{"location":"reference/#pyradiance.View.voff","title":"<code>voff</code>  <code>property</code>","text":"<p>View vertical offset</p>"},{"location":"reference/#pyradiance.View.vp","title":"<code>vp</code>  <code>property</code>","text":"<p>View position: x, y, z</p>"},{"location":"reference/#pyradiance.View.vu","title":"<code>vu</code>  <code>property</code>","text":"<p>View up direction: x, y, z</p>"},{"location":"reference/#pyradiance.View.vvec","title":"<code>vvec</code>  <code>property</code>","text":"<p>(self) -&gt; tuple</p>"},{"location":"reference/#pyradiance.View.__init__","title":"<code>__init__()</code>  <code>method descriptor</code>","text":"<p>init(self) -&gt; None</p>"},{"location":"reference/#pyradiance.View.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#pyradiance.WrapBSDF","title":"<code>WrapBSDF</code>","text":""},{"location":"reference/#pyradiance.WrapBSDF.__init__","title":"<code>__init__(inxml=None, enforce_window=False, comment=None, correct_solid_angle=False, basis=None, unlink=False, unit=None, geometry=None, **kwargs)</code>","text":"<p>Initialize wrapper operation of BSDF data into XML</p> <p>Parameters:</p> Name Type Description Default <code>inxml</code> <code>None | str | Path</code> <p>input xml file</p> <code>None</code> <code>enforce_window</code> <p>Enforcing LBNL Window XML schema,</p> <code>False</code> <code>comment</code> <code>None | str</code> <p>additional comment to add to XML,</p> <code>None</code> <code>correct_solid_angle</code> <p>Correct the input BSDF by solid angles,</p> <code>False</code> <code>basis</code> <code>None | str</code> <p>BSDF basis to use, \"kf\", \"kh\", \"kq\",</p> <code>None</code> <code>unlink</code> <code>bool</code> <p>Whether to remove input file after creating XML file,</p> <code>False</code> <code>unit</code> <p>BSDF geometry unit,</p> <code>None</code> <code>geometry</code> <p>Whether to include geometry in XML,</p> <code>None</code> <code>**kwargs</code> <p>Additional tags to be passed into XML</p> <code>{}</code>"},{"location":"reference/#pyradiance.WrapBSDF.add_solar","title":"<code>add_solar(tb=None, tf=None, rb=None, rf=None)</code>","text":"<p>Insert commands for solar data</p> <p>Parameters:</p> Name Type Description Default <code>tb</code> <code>None | str</code> <p>back transmittance file</p> <code>None</code> <code>tf</code> <code>None | str</code> <p>front transmittance file</p> <code>None</code> <code>rb</code> <code>None | str</code> <p>back reflectance file</p> <code>None</code> <code>rf</code> <code>None | str</code> <p>front reflectance file</p> <code>None</code> <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.WrapBSDF.add_visible","title":"<code>add_visible(tb=None, tf=None, rb=None, rf=None)</code>","text":"<p>Insert commands for visible data</p> <p>Parameters:</p> Name Type Description Default <code>tb</code> <code>None | str</code> <p>back transmittance file</p> <code>None</code> <code>tf</code> <code>None | str</code> <p>front transmittance file</p> <code>None</code> <code>rb</code> <code>None | str</code> <p>back reflectance file</p> <code>None</code> <code>rf</code> <code>None | str</code> <p>front reflectance file</p> <code>None</code> <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform","title":"<code>Xform</code>","text":""},{"location":"reference/#pyradiance.Xform.__init__","title":"<code>__init__(inp, expand_cmd=True, invert=False, iprefix=None, modifier=None)</code>","text":"<p>Initialize a transformation operation of a RADIANCE scene description</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path | bytes</code> <p>Input file or bytes</p> required <code>expand_cmd</code> <code>bool</code> <p>Set to True to expand command</p> <code>True</code> <code>iprefix</code> <code>None | str</code> <p>Prefix identifier</p> <code>None</code> <code>modifier</code> <code>None | str</code> <p>Set surface modifier to this name</p> <code>None</code> <code>invert</code> <code>bool</code> <p>Invert surface normal</p> <code>False</code>"},{"location":"reference/#pyradiance.Xform.array","title":"<code>array(number)</code>","text":"<p>Insert array command.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>array number</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.iterate","title":"<code>iterate(number)</code>","text":"<p>Insert iterate command.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>iterate number</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.mirrorx","title":"<code>mirrorx()</code>","text":"<p>Insert mirror about yz plane command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.mirrory","title":"<code>mirrory()</code>","text":"<p>Insert mirror about xz plane command.</p> <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.mirrorz","title":"<code>mirrorz()</code>","text":"<p>Insert mirror about xy plane command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.rotatex","title":"<code>rotatex(deg)</code>","text":"<p>Insert rotation around x axis command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <code>float</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.rotatey","title":"<code>rotatey(deg)</code>","text":"<p>Insert rotation around x axis command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <code>float</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.rotatez","title":"<code>rotatez(deg)</code>","text":"<p>Insert rotation around x axis command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <code>float</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.scale","title":"<code>scale(ratio)</code>","text":"<p>Insert rotation around x axis command.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <p>rotation in degree</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.Xform.translate","title":"<code>translate(x, y, z)</code>","text":"<p>Insert translate command.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>translation in x coordinate</p> required <code>y</code> <code>float</code> <p>translation in y coordinate</p> required <code>z</code> <code>float</code> <p>translation in z coordinate</p> required <p>Returns:</p> Type Description <p>self</p>"},{"location":"reference/#pyradiance.bsdf2klems","title":"<code>bsdf2klems(*inp, spp=None, half=False, quater=False, progress_bar=False, progress_bar_length=None, maxlobes=None, forward=False, backward=True, expr=None, file=None)</code>","text":"<p>Generate XML Klems matrix description of a BSDF.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to XML file</p> <code>()</code> <code>spp</code> <code>None | int</code> <p>number of samples for each input-output patch pair, default=1024.</p> <code>None</code> <code>half</code> <code>bool</code> <p>Generate instead a half Klems basis XML.</p> <code>False</code> <code>quater</code> <code>bool</code> <p>Generate instead a quater Klems basis XML.</p> <code>False</code> <code>progress_bar</code> <code>bool</code> <p>toggle to show progress bar.</p> <code>False</code> <code>progress_bar_length</code> <code>None | int</code> <p>length of the progress bar, default=79 characters.</p> <code>None</code> <code>maxlobes</code> <code>None | int</code> <p>maximum number of lobes in any interpolated radial basis function (default=15000). Setting the value to 0 turns off this limit.</p> <code>None</code> <code>forward</code> <code>bool</code> <p>generate forward matrix (default=off).</p> <code>False</code> <code>backward</code> <code>bool</code> <p>generate backward matrixi (default=on).</p> <code>True</code> <code>expr</code> <code>None | str</code> <p>expression to evaluate.</p> <code>None</code> <code>file</code> <code>None | str</code> <p>file to write the output to</p> <code>None</code> <p>Returns:</p> Type Description <p>The output of the command</p>"},{"location":"reference/#pyradiance.bsdf2ttree","title":"<code>bsdf2ttree(*inp, isotropic=False, reciprocity_averaging=True, resolution=6, percent_cull=[90], super_samples=256, difference_threshold=0.35, progress_bar=False, progress_bar_length=None, maxlobes=15000, forward=False, backward=True, expr=None, file=None)</code>","text":"<p>Generate XML tensor tree description of a BSDF.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to XML file</p> <code>()</code> <code>isotropic</code> <code>bool</code> <p>Generate an isotropic ttree.</p> <code>False</code> <code>reciprocity_averaging</code> <code>bool</code> <p>Use reciprocity averaging.</p> <code>True</code> <code>resolution</code> <code>int</code> <p>resolution of the ttree.</p> <code>6</code> <code>percent_cull</code> <code>Sequence[float]</code> <p>percent of the ttree to cull.</p> <code>[90]</code> <code>super_samples</code> <code>int</code> <p>number of samples for each input-output patch pair, default=1024.</p> <code>256</code> <code>difference_threshold</code> <code>float</code> <p>difference threshold for culling.</p> <code>0.35</code> <code>progress_bar</code> <code>bool</code> <p>toggle to show progress bar.</p> <code>False</code> <code>progress_bar_length</code> <code>None | int</code> <p>length of the progress bar, default=79 characters.</p> <code>None</code> <code>maxlobes</code> <code>int</code> <p>maximum number of lobes in any interpolated radial basis function (default=15000). Setting the value to 0 turns off this limit.</p> <code>15000</code> <code>forward</code> <code>bool</code> <p>generate forward matrix (default=off).</p> <code>False</code> <code>backward</code> <code>bool</code> <p>generate backward matrixi (default=on).</p> <code>True</code> <code>expr</code> <code>None | str</code> <p>expression to evaluate.</p> <code>None</code> <code>file</code> <code>None | str</code> <p>file to write the output to</p> <code>None</code> <p>Returns:</p> Type Description <p>Tensor tree BSDF XML in bytes</p>"},{"location":"reference/#pyradiance.cnt","title":"<code>cnt(*dims, shuffled=False)</code>","text":"<p>Index counter.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>int</code> <p>list of dimensions</p> <code>()</code> <code>shuffled</code> <code>bool</code> <p>if True, the output will be shuffled</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of cnt</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cnt(2, 3)\nb'0 0\\n0 1\\n0 2\\n1 0\\n1 1\\n1 2\\n'\n&gt;&gt;&gt; cnt(2, 3, shuffled=True)\nb'1 2\\n0 1\\n1 0\\n0 2\\n1 1\\n0 0\\n'\n</code></pre>"},{"location":"reference/#pyradiance.create_default_view","title":"<code>create_default_view(*args, **kwargs)</code>","text":"<p>create_default_view() -&gt; pyradiance.rad_params.View</p>"},{"location":"reference/#pyradiance.dctimestep","title":"<code>dctimestep(*mtx, nstep=None, header=True, xres=None, yres=None, inform=None, outform=None, ospec=None)</code>","text":"<p>Call dctimestep to perform matrix multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>mtx</code> <p>input matrices</p> <code>()</code> <code>nstep</code> <code>None | int</code> <p>number of steps</p> <code>None</code> <code>header</code> <code>bool</code> <p>include header</p> <code>True</code> <code>xres</code> <code>None | int</code> <p>x resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>y resolution</p> <code>None</code> <code>inform</code> <code>None | str</code> <p>input format</p> <code>None</code> <code>outform</code> <code>None | str</code> <p>output format</p> <code>None</code> <code>ospec</code> <code>None | str</code> <p>output specification</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>None | bytes</code> <p>output of dctimestep</p>"},{"location":"reference/#pyradiance.evalglare","title":"<code>evalglare(inp, view=None, detailed=False, ev_only=False, ev=None, smooth=False, threshold=None, task_area=None, masking_file=None, band_lum_angle=None, check_file=None, correction_mode=None, peak_extraction=True, peak_extraction_value=50000, bg_lum_mode=0, search_radius=0.2, version=False, source_color=None, fast=None)</code>","text":"<p>Run evalglare on a Radiance image.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>input image</p> required <code>view</code> <code>None | list[str]</code> <p>view parameters</p> <code>None</code> <code>detailed</code> <code>bool</code> <p>detailed output</p> <code>False</code> <code>ev_only</code> <code>bool</code> <p>return vertical illuminance value</p> <code>False</code> <code>ev</code> <code>None | float</code> <p>vertical illuminance value to use instead of the one computer from the image.</p> <code>None</code> <code>smooth</code> <code>bool</code> <p>enable smoothing function.</p> <code>False</code> <code>threshold</code> <code>None | float</code> <p>Threshold factor.</p> <code>None</code> <code>task_area</code> <code>None | tuple</code> <p>task area</p> <code>None</code> <code>masking_file</code> <code>None | str | Path</code> <p>masking file</p> <code>None</code> <code>band_lum_angle</code> <code>None | float</code> <p>band luminance angle</p> <code>None</code> <code>check_file</code> <code>None | str | Path</code> <p>check file path.</p> <code>None</code> <code>correction_mode</code> <code>None | str</code> <p>correction mode</p> <code>None</code> <code>peak_extraction</code> <code>bool</code> <p>enable luminance peak extraction</p> <code>True</code> <code>peak_extraction_value</code> <code>float</code> <p>luminance peak extraction value</p> <code>50000</code> <code>bg_lum_mode</code> <code>int</code> <p>background luminance calculation mode</p> <code>0</code> <code>search_radius</code> <code>float</code> <p>search radius</p> <code>0.2</code> <code>version</code> <code>bool</code> <p>print version</p> <code>False</code> <code>source_color</code> <code>None | tuple[float, float, float]</code> <p>source color</p> <code>None</code> <p>Returns:</p> Type Description <p>Evalglare output</p>"},{"location":"reference/#pyradiance.falsecolor","title":"<code>falsecolor(inp, pic_overlay=None, contour=None, extrema=False, scale=None, digits=None, label=None, ndivs=None, lwidth=None, lheight=None, decades=None, multiplier=None, palette=None, redv=None, grnv=None, bluv=None)</code>","text":"<p>Generate a falsecolor Radiance picture.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path | bytes</code> <p>Path or bytes to input picture file.</p> required <code>pic_overlay</code> <code>None | str</code> <p>Path to another picture to overlay with contours.</p> <code>None</code> <code>contour</code> <code>None | str</code> <p>Type of contour ('b' for bands, 'l' for lines, 'p' for posterization).</p> <code>None</code> <code>extrema</code> <code>bool</code> <p>Flag to print extrema points on the brightest and darkest pixels.</p> <code>False</code> <code>scale</code> <code>None | str</code> <p>Scale for the false color (e.g., 'auto' or specific scale).</p> <code>None</code> <code>digits</code> <code>None | int</code> <p>Max number of decimal places for legend entries.</p> <code>None</code> <code>label</code> <code>None | str</code> <p>Label for the new image.</p> <code>None</code> <code>ndivs</code> <code>None | int</code> <p>Number of contours and corresponding legend entries.</p> <code>None</code> <code>lwidth</code> <code>None | int</code> <p>Width of the legend.</p> <code>None</code> <code>lheight</code> <code>None | int</code> <p>Height of the legend.</p> <code>None</code> <code>decades</code> <code>None | int</code> <p>Number of decades below the maximum scale for logarithmic mapping.</p> <code>None</code> <code>multiplier</code> <code>None | float</code> <p>Multiplier for the scale (e.g., to convert units).</p> <code>None</code> <code>palette</code> <code>None | str</code> <p>Color palette to use for false color.</p> <code>None</code> <code>redv</code> <code>None | str</code> <p>Expression for mapping values to red.</p> <code>None</code> <code>grnv</code> <code>None | str</code> <p>Expression for mapping values to green.</p> <code>None</code> <code>bluv</code> <code>None | str</code> <p>Expression for mapping values to blue.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>Output of falsecolor.</p>"},{"location":"reference/#pyradiance.genblinds","title":"<code>genblinds(mat, name, depth, width, height, nslats, angle, rcurv=None)</code>","text":"<p>Generate a RADIANCE description of venetian blinds.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>str</code> <p>Material name</p> required <code>name</code> <code>str</code> <p>Name of the blinds</p> required <code>depth</code> <code>float</code> <p>Depth of the blinds</p> required <code>width</code> <code>float</code> <p>Width of the blinds</p> required <code>height</code> <code>float</code> <p>Height of the blinds</p> required <code>nslats</code> <code>int</code> <p>Number of slats</p> required <code>angle</code> <code>float</code> <p>Angle of the slats</p> required <code>rcurv</code> <code>None | float</code> <p>Radius of curvature of the slats, + for upward curvature, - for downward</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>RADIANCE description of the blinds</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; genblinds('mat', 'blinds', 0.1, 0.5, 1.0, 4, 45, 0.1)\n</code></pre>"},{"location":"reference/#pyradiance.genbox","title":"<code>genbox(mat, name, xsiz, ysiz, zsiz, inward=False, beveled=None, rounded=None, nsegs=None, smoothing=False, waveout=False)</code>","text":"<p>Generate a box.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>str</code> <p>material name</p> required <code>name</code> <code>str</code> <p>box name</p> required <code>xsiz</code> <code>float</code> <p>size in x dimension</p> required <code>ysiz</code> <code>float</code> <p>size in y dimension</p> required <code>zsiz</code> <code>float</code> <p>size in z dimension</p> required <code>inward</code> <code>bool</code> <p>box facing inward</p> <code>False</code> <code>beveled</code> <code>None | float</code> <p>beveled size</p> <code>None</code> <code>rounded</code> <code>None | float</code> <p>rounded corner size</p> <code>None</code> <code>nsegs</code> <code>None | int</code> <p>number of segments</p> <code>None</code> <code>smoothing</code> <code>bool</code> <p>to smooth</p> <code>False</code> <code>waveout</code> <code>bool</code> <p>wavefront (.obj) out</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>the box</p>"},{"location":"reference/#pyradiance.gendaylit","title":"<code>gendaylit(dt, latitude, longitude, timezone, year=None, dirnorm=None, diffhor=None, dirhor=None, dirnorm_illum=None, diffhor_illum=None, solar=False, sky_only=False, silent=False, grefl=None, interval=None)</code>","text":"<p>Generates a RADIANCE description of the daylight sources using Perez models for direct and diffuse components.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>python datetime object</p> required <code>latitude</code> <code>float</code> <p>latitude in degrees</p> required <code>longitude</code> <code>float</code> <p>longitude in degrees</p> required <code>timezone</code> <code>int</code> <p>standard meridian timezone, e.g., 120 for PST</p> required <code>year</code> <code>None | int</code> <p>Need to set it explicitly, won't use year in datetime object</p> <code>None</code> <code>dirnorm</code> <code>None | float</code> <p>direct normal irradiance</p> <code>None</code> <code>diffhor</code> <code>None | float</code> <p>diffuse horizontal irradiance</p> <code>None</code> <code>dirhor</code> <code>None | float</code> <p>direct horizontal irradiance, either this or dirnorm</p> <code>None</code> <code>dirnormp</code> <p>direct normal illuminance</p> required <code>diffhorp</code> <p>diffuse horizontal illuminance</p> required <code>solar</code> <code>bool</code> <p>if True, include solar position</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>bytes</code> <p>output of gendaylit</p>"},{"location":"reference/#pyradiance.gendaymtx","title":"<code>gendaymtx(weather_data, verbose=False, header=True, average=False, sun_only=False, sky_only=False, sun_file=None, sun_mods=None, daylight_hours_only=False, dryrun=False, sky_color=None, ground_color=None, rotate=None, outform=None, onesun=False, solar_radiance=False, mfactor=1)</code>","text":"<p>Generate an annual Perez sky matrix from a weather tape.</p> <p>Parameters:</p> Name Type Description Default <code>weather_data</code> <code>str | Path | bytes</code> <p>weather data</p> required <code>mfactor</code> <code>int</code> <p>multiplication factor</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>verbose</p> <code>False</code> <code>header</code> <code>bool</code> <p>header</p> <code>True</code> <code>average</code> <code>bool</code> <p>average</p> <code>False</code> <code>sun_only</code> <code>bool</code> <p>sun only</p> <code>False</code> <code>sky_only</code> <code>bool</code> <p>sky only</p> <code>False</code> <code>sun_file</code> <code>None | str</code> <p>sun file</p> <code>None</code> <code>sun_mods</code> <code>None | str</code> <p>sun mods</p> <code>None</code> <code>daylight_hours_only</code> <code>bool</code> <p>daylight hours only</p> <code>False</code> <code>dryrun</code> <code>bool</code> <p>dryrun</p> <code>False</code> <code>sky_color</code> <code>None | list[float]</code> <p>sky color</p> <code>None</code> <code>ground_color</code> <code>None | list[float]</code> <p>ground color</p> <code>None</code> <code>rotate</code> <code>None | float</code> <p>rotate</p> <code>None</code> <code>outform</code> <code>None | str</code> <p>outform</p> <code>None</code> <code>onesun</code> <code>bool</code> <p>onesun</p> <code>False</code> <code>solar_radiance</code> <code>bool</code> <p>solar radiance</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <p>output of gendaymtx</p>"},{"location":"reference/#pyradiance.gensdaymtx","title":"<code>gensdaymtx(weather_data, verbose=False, header=True, sun_only=False, sky_only=False, daylight_hours_only=False, ground_reflectance=None, rotate=None, outform=None, onesun=False, mfactor=1, nthreads=1)</code>","text":"<p>Generate an annual spectral sky matrix from a weather tape.</p> <p>Parameters:</p> Name Type Description Default <code>weather_data</code> <code>str | Path | bytes</code> <p>weather data</p> required <code>mfactor</code> <code>int</code> <p>multiplication factor</p> <code>1</code> <code>verbose</code> <code>bool</code> <p>verbose</p> <code>False</code> <code>header</code> <code>bool</code> <p>header</p> <code>True</code> <code>sun_only</code> <code>bool</code> <p>sun only</p> <code>False</code> <code>sky_only</code> <code>bool</code> <p>sky only</p> <code>False</code> <code>daylight_hours_only</code> <code>bool</code> <p>daylight hours only</p> <code>False</code> <code>ground_reflectance</code> <code>None | list[float]</code> <p>ground color</p> <code>None</code> <code>rotate</code> <code>None | float</code> <p>rotate</p> <code>None</code> <code>outform</code> <code>None | str</code> <p>outform</p> <code>None</code> <code>onesun</code> <code>bool</code> <p>onesun</p> <code>False</code> <code>nthreads</code> <code>int</code> <p>number of threads to use for precomputations</p> <code>1</code> <p>Returns:</p> Name Type Description <code>bytes</code> <p>output of gensdaymtx</p>"},{"location":"reference/#pyradiance.gensky","title":"<code>gensky(dt=None, latitude=None, longitude=None, timezone=None, altitude=None, azimuth=None, year=None, sunny_with_sun=False, sunny_without_sun=False, cloudy=False, intermediate_with_sun=False, intermediate_without_sun=False, uniform=False, ground_reflectance=None, zenith_brightness=None, horizontal_brightness=None, solar_radiance=None, horizontal_direct_irradiance=None, turbidity=None)</code>","text":"<p>Generate a RADIANCE description of the sky.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>None | datetime</code> <p>datetime object, mutally exclusive with altitude and azimuth</p> <code>None</code> <code>latitude</code> <code>None | float</code> <p>latitude, only apply if dt is not None</p> <code>None</code> <code>longitude</code> <code>None | float</code> <p>longitude, only apply if dt is not None</p> <code>None</code> <code>timezone</code> <code>None | int</code> <p>timezone, only apply if dt is not None</p> <code>None</code> <code>altitude</code> <code>None | float</code> <p>solar altitude, mutally exclusive with dt</p> <code>None</code> <code>azimuth</code> <code>None | float</code> <p>solar azimuth, mutally exclusive with dt</p> <code>None</code> <code>year</code> <code>None | int</code> <p>year, only apply if dt is not None</p> <code>None</code> <code>sunny_with_sun</code> <code>bool</code> <p>sunny with sun</p> <code>False</code> <code>sunny_without_sun</code> <code>bool</code> <p>sunny without sun</p> <code>False</code> <code>cloudy</code> <code>bool</code> <p>CIE overcast sky</p> <code>False</code> <code>intermediate_with_sun</code> <code>bool</code> <p>intermediate with sun</p> <code>False</code> <code>intermediate_without_sun</code> <code>bool</code> <p>intermediate without sun</p> <code>False</code> <code>uniform</code> <code>bool</code> <p>uniform sky</p> <code>False</code> <code>ground_reflectance</code> <code>None | float</code> <p>ground reflectance</p> <code>None</code> <code>zenith_brightness</code> <code>None | float</code> <p>zenith brightness in watts/steradian/meter^2</p> <code>None</code> <code>horizontal_brightness</code> <code>None | float</code> <p>horizontal brightness in watts/metere^2</p> <code>None</code> <code>solar_radiance</code> <code>None | float</code> <p>solar radiance in watts/steradian/meter^2</p> <code>None</code> <code>horizontal_direct_irradiance</code> <code>None | float</code> <p>horizontal direct irradiance in watts/meter^2</p> <code>None</code> <code>turbidity</code> <code>None | float</code> <p>turbidity factor</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>bytes</code> <p>output of gensky</p>"},{"location":"reference/#pyradiance.genssky","title":"<code>genssky(dt, latitude=37.7, longitude=122.2, timezone=120, year=None, res=64, cloud_cover=0.0, ground_reflectance=0.2, broadband_aerosol_optical_depth=0.115, mie_file=None, nthreads=1, out_dir='.', out_name='out', dir_norm_illum=None, diff_hor_illum=None)</code>","text":"<p>Generate a RADIANCE description of the spectral sky.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>datetime object, mutally exclusive with altitude and azimuth</p> required <code>latitude</code> <code>float</code> <p>latitude, only apply if dt is not None</p> <code>37.7</code> <code>longitude</code> <code>float</code> <p>longitude, only apply if dt is not None</p> <code>122.2</code> <code>timezone</code> <code>int</code> <p>timezone, only apply if dt is not None</p> <code>120</code> <code>year</code> <code>None | int</code> <p>year, only apply if dt is not None</p> <code>None</code> <code>res</code> <code>int</code> <p>hsr image resolution, default: 64,</p> <code>64</code> <code>cloud_cover</code> <code>float</code> <p>cloud cover 0.0: clear, 1.0: overcast,</p> <code>0.0</code> <code>ground_reflectance</code> <code>float</code> <p>default: 0.2,</p> <code>0.2</code> <code>broadband_aerosol_optical_depth</code> <code>float</code> <p>default: 0.115,</p> <code>0.115</code> <code>mie_file</code> <code>None | str</code> <p>mie scattering coefficient source file</p> <code>None</code> <code>nthreads</code> <code>int</code> <p>number of threads used for precomputation, default:1,</p> <code>1</code> <code>out_dir</code> <code>str</code> <p>directory to save precomputed data that can be reused, default to current working directory.  This can be changed to RAYPATH for cross-section data reused.</p> <code>'.'</code> <code>out_name</code> <code>str</code> <p>output file name, defautl: \"out\"</p> <code>'out'</code> <code>dir_norm_illum</code> <code>None | float</code> <p>direct normal illuminance to calibrate the output against,</p> <code>None</code> <code>diff_hor_illum</code> <code>None | float</code> <p>diffuse horizontal illuminance to calibrate the output against.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>bytes</code> <p>output of gensky</p>"},{"location":"reference/#pyradiance.get_default_ray_params","title":"<code>get_default_ray_params(*args, **kwargs)</code>","text":"<p>get_default_ray_params() -&gt; pyradiance.rad_params.RayParams</p>"},{"location":"reference/#pyradiance.get_header","title":"<code>get_header(inp, dimension=False)</code>","text":"<p>Get header information from a Radiance file.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>input file or bytes</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>header</p>"},{"location":"reference/#pyradiance.get_image_dimensions","title":"<code>get_image_dimensions(image)</code>","text":"<p>Get the dimensions of an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | Path | bytes</code> <p>image file path or image bytes</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>Tuple[int, int]: width and height</p>"},{"location":"reference/#pyradiance.get_ray_params_args","title":"<code>get_ray_params_args(*args, **kwargs)</code>","text":"<p>get_ray_params_args(arg: pyradiance.rad_params.RayParams, /) -&gt; list</p> <p>Returns a list of strings given a RayParams object</p>"},{"location":"reference/#pyradiance.get_view_args","title":"<code>get_view_args(*args, **kwargs)</code>","text":"<p>get_view_args(arg: pyradiance.rad_params.View, /) -&gt; list</p> <p>Returns a list of string for the view</p>"},{"location":"reference/#pyradiance.getinfo","title":"<code>getinfo(*inputs, dimension_only=False, dimension=False, strip_header=False, replace='', append='', command='')</code>","text":"<p>Get header information from a Radiance file.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>str | Path | bytes</code> <p>input file or bytes</p> <code>()</code> <code>dimension_only</code> <code>bool</code> <p>return only the dimension</p> <code>False</code> <code>dimension</code> <code>bool</code> <p>return the dimension</p> <code>False</code> <code>strip_header</code> <code>bool</code> <p>strip header from the output</p> <code>False</code> <code>replace</code> <code>str</code> <p>replace the header with this string</p> <code>''</code> <code>append</code> <code>str</code> <p>append this string to the header</p> <code>''</code> <code>command</code> <code>str</code> <p>command to use to get the header</p> <code>''</code> <p>Returns:</p> Type Description <code>bytes</code> <p>getinfo output</p>"},{"location":"reference/#pyradiance.ies2rad","title":"<code>ies2rad(*inp, libdir=None, prefdir=None, outname=None, stdout=False, units=None, radius=None, instancing_geometry=False, lampdat=None, lamp_type=None, lamp_color=None, set_default_lamp_color=None, multiply_factor=None)</code>","text":"<p>Convert IES luminaire data to RADIANCE description.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path</code> <p>Path to IES file</p> <code>()</code> <code>libdir</code> <code>None | str</code> <p>Path to directory where the library files are located.</p> <code>None</code> <code>outname</code> <code>None | str</code> <p>Output file name root.</p> <code>None</code> <code>stdout</code> <code>bool</code> <p>Print the output to stdout.</p> <code>False</code> <code>units</code> <code>None | str</code> <p>Set the units of the output file.</p> <code>None</code> <code>rad</code> <p>ignore the crude geometry given by the IES input file and use instead an illum sphere with radius rad.</p> required <code>instancing_geometry</code> <code>bool</code> <p>compile MGF detail geometry into a separate octree and create a single instance referencing it.</p> <code>False</code> <code>lampdat</code> <code>None | str</code> <p>map lamp name to xy chromaticity and lumen depreciation data.</p> <code>None</code> <code>lamp_type</code> <code>None | str</code> <p>lamp type.</p> <code>None</code> <code>lamp_color</code> <code>None | str</code> <p>set lamp color to red green blue if lamp type is unknown.</p> <code>None</code> <code>set_default_lamp_color</code> <code>None | str</code> <p>set default lamp color according to the entry for lamp in the lookup table.</p> <code>None</code> <code>multiply_factor</code> <code>None | float</code> <p>multiply all output quantities by this factor. This is the best way to scale fixture brightness for different lamps.</p> <code>None</code> <p>Returns:</p> Type Description <p>The output of the command</p>"},{"location":"reference/#pyradiance.load_material_smd","title":"<code>load_material_smd(file, roughness=0.0, spectral=False, metal=False)</code>","text":"<p>Generate Radiance primitives from csv file from spectral material database (spectraldb.com).</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>Path to .csv file</p> required <code>roughness</code> <code>float</code> <p>Roughtness of material</p> <code>0.0</code> <code>spectral</code> <p>Output spectral primitives</p> <code>False</code> <code>metal</code> <p>Whether material is metal</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Primitive]</code> <p>A list of primitives</p>"},{"location":"reference/#pyradiance.mgf2rad","title":"<code>mgf2rad(*inp, matfile=None, mult=None, dist=None)</code>","text":"<p>Convert Materials and Geometry Format file to RADIANCE description.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to MGF file</p> <code>()</code> <code>matfile</code> <p>Path to material file where the translated materials will be written.</p> <code>None</code> <code>mult</code> <p>multiplier for all the emission values</p> <code>None</code> <code>dist</code> <p>glow distance (in meters) for all emitting surfaces.</p> <code>None</code> <p>Returns:</p> Type Description <p>The output of the command</p>"},{"location":"reference/#pyradiance.mkillum","title":"<code>mkillum(inp, octree, nproc=1, params=None)</code>","text":"<p>Compute illum sources for a RADIANCE scene</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes</code> <p>input file content as bytes</p> required <code>octree</code> <code>str | Path</code> <p>octree file</p> required <code>nproc</code> <code>int</code> <p>number of processes</p> <code>1</code> <code>params</code> <code>None | Sequence[str]</code> <p>additional parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Output of mkillum in bytes</p>"},{"location":"reference/#pyradiance.mkpmap","title":"<code>mkpmap(octree, global_map=None, caustic_map=None, volume_map=None, direct_map=None, contrib_map=None, pre_global_map=None, predistrib=None, rect_region=None, sphere_region=None, maxbounce=None, maxprepass=None, port_mod=None, port_modfile=None, precomp=None, seed=None, virtual_mod=None, virtual_modfile=None, amb_excl_mod=None, amb_excl_modfile=None, amb_incl_mod=None, amb_incl_modfile=None, backface_vis=False, sample_res=None, partition_size=None, progress_file=None, overwrite=False, maxdist=None, scattering_albedo=None, extinction_coefficient=None, scattering_eccentricity=None, nproc=1, progress_interval=None)</code>","text":"<p>Mkpmap takes a RADIANCE scene description as an octree and performs Monte Carlo forward path tracing from the light sources, depositing indirect ray hitpoints along with their energy (flux) as \"photons\". The resulting localised energy distribution represents a global illumination solution which is written to a file for subsequent evaluation by rpict(1), rtrace(1) and rvu(1) in a backward raytracing pass. The photon map(s) can be reused for multiple viewpoints and sensor locations as long as the geometry remains unchanged. Args:     octree: Octree file path.     global_map: Global map file path and number of photons.     caustic_map: Caustic map file path and number of photons.     volume_map: Volume map file path and number of photons.     direct_map: Direct map file path and number of photons.     contrib_map: Contribution map file path and number of photons.     pre_global_map: Precomputed global map file path, number of photons and bandwidth.     predistrib: Photon predistribution factor.     rect_region: Rectangular region     sphere_region: Spherical region     maxbounce: Maximum number of bounces.     maxprepass: Maximum number of iteratiosn of distributoin prepass before terminating.     port_mod: Specifies a modifier to act as a photon port.     port_modfile: File with modifiers to act as photon ports.     precomp: Fraction of global photons to precompute.     seed: Random seed.     virtual_mod: Specifies a modifier to act as a virtual source.     virtual_modfile: File with modifiers to act as virtual sources.     amb_excl_mod: Specifies a modifier to exclude from ambient calculation.     amb_excl_modfile: File with modifiers to exclude from ambient calculation.     amb_incl_mod: Specifies a modifier to include in ambient calculation.     amb_incl_modfile: File with modifiers to include in ambient calculation.     backface_vis: Backface visibility.     sample_res: Sample resolution.</p>"},{"location":"reference/#pyradiance.obj2mesh","title":"<code>obj2mesh(inp, matfiles=None, matlib=None, objlim=9, maxres=16384, silent=False, stats=False)</code>","text":"<p>Convert Wavefront .OBJ file to RADIANCE description.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes | str | Path</code> <p>Path to OBJ file, or bytes</p> required <code>matfiles</code> <code>None | Sequence[str]</code> <p>Radiance material files to use</p> <code>None</code> <code>matlib</code> <code>None | str</code> <p>Radiance material library file, RAYPATH are searched</p> <code>None</code> <code>objlim</code> <code>int</code> <p>the maximum surface setsize for each voxel</p> <code>9</code> <code>maxres</code> <code>int</code> <p>Maximum octree resolution</p> <code>16384</code> <code>silent</code> <code>bool</code> <p>Suppress warnings</p> <code>False</code> <code>stats</code> <code>bool</code> <p>Print statistics</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The converted RADIANCE scene description in bytes</p>"},{"location":"reference/#pyradiance.obj2rad","title":"<code>obj2rad(inp, quallist=False, flatten=False, mapfile=None, objname=None)</code>","text":"<p>Convert Wavefront .OBJ file to RADIANCE description.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>bytes | str | Path</code> <p>Path to OBJ file</p> required <code>quallist</code> <code>bool</code> <p>Produce a list of qualifiers from which to construct a mapping for the given .OBJ file.</p> <code>False</code> <code>flatten</code> <code>bool</code> <p>Flatten all faces, effectively ignoring vertex normal information.</p> <code>False</code> <code>mapfile</code> <code>None | str</code> <p>Mapping rules files for assigning material names for the surfaces.</p> <code>None</code> <code>objname</code> <code>None | str</code> <p>Specify the name of this object, though it will be overriden by any \"o\" statements in the input file.  If this option is absent, and there are no \"o\" statements, obj2rad will attempt to name surfaces based on their group associations.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The converted RADIANCE scene description in bytes</p>"},{"location":"reference/#pyradiance.oconv","title":"<code>oconv(*paths, warning=True, stdin=None, frozen=False, octree=None)</code>","text":"<p>Run Radiance oconv tool to build an octree.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <p>list of Radiance files</p> <code>()</code> <code>warning</code> <p>if False, warnings will be suppressed</p> <code>True</code> <code>stdin</code> <p>if not None, stdin will be used</p> <code>None</code> <code>frozen</code> <code>bool</code> <p>if True, the octree will be frozen</p> <code>False</code> <code>octree</code> <p>if provided, the resulting octree incorporate existing one</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of oconv</p>"},{"location":"reference/#pyradiance.pabopto2bsdf","title":"<code>pabopto2bsdf(*inp, nproc=1, symmetry=None, angle=None, reverse=False)</code>","text":"<p>Convert BSDF measurements to a scattering interpolant representation.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>pab-opto Mountain files, need two or more.</p> <code>()</code> <code>nproc</code> <code>int</code> <p>number of processors to use.</p> <code>1</code> <code>symmetry</code> <code>None | str</code> <p>BSDF symmetry, which is one of \"isotropic\", \"quadrilateral\", \"bilateral\", \"up\", or \"anisotropic\".  Any of these may be abbreviated with as little as a single letter, and case is ignored.</p> <code>None</code> <code>angle</code> <code>None | float</code> <p>cull scattered measurements that are nearer to grazing than the given angle in degrees.  If the word \"auto\" (which can be abbreviated as 'a' or 'A') is given instead of an angle, then the near-grazing angle will be determined by the lowest incident angle measurement present in the input data.  This is sometimes necessary to eliminate noise and edge effects that some measurements exhibit near grazing.</p> <code>None</code> <code>reverse</code> <p>reverses the assumed sample orientation front-to-back, and is discussed below under the \"#intheta\" header entry.</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>SIR data in bytes</p>"},{"location":"reference/#pyradiance.parse_primitive","title":"<code>parse_primitive(pstr)</code>","text":"<p>Parse Radiance primitives inside a file path into a list of dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>pstr</code> <code>str</code> <p>A string of Radiance primitives.</p> required <p>Returns:</p> Type Description <code>list[Primitive]</code> <p>list of primitives</p>"},{"location":"reference/#pyradiance.parse_view","title":"<code>parse_view(*args, **kwargs)</code>","text":"<p>parse_view(arg: str, /) -&gt; pyradiance.rad_params.View</p> <p>Parse a view string into a View object</p>"},{"location":"reference/#pyradiance.pcompos","title":"<code>pcompos(inputs, pos=None, xres=None, yres=None, spacing=0, background=None, anchors=None, header=True, lower_threashold=None, upper_threshold=None, label=None, label_height=None, ncols=None, anchor_point=None)</code>","text":"<p>Composite Radiance pictures</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>Sequence[Path | str | bytes]</code> <p>list of input files</p> required <code>pos</code> <code>None | Sequence[Sequence[float]]</code> <p>list of positions</p> <code>None</code> <code>xres</code> <code>None | int</code> <p>horizontal resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>vertical resolution</p> <code>None</code> <code>spacing</code> <code>int</code> <p>spacing between images</p> <code>0</code> <code>background</code> <code>None | tuple[float, float, float]</code> <p>background color</p> <code>None</code> <code>anchors</code> <code>None | Sequence[str]</code> <p>list of anchors</p> <code>None</code> <code>header</code> <code>bool</code> <p>set to False if want to reduce header</p> <code>True</code> <code>lower_threashold</code> <code>None | float</code> <p>lower threshold</p> <code>None</code> <code>upper_threshold</code> <code>None | float</code> <p>upper threshold</p> <code>None</code> <code>label</code> <code>None | str</code> <p>label</p> <code>None</code> <code>label_height</code> <code>None | int</code> <p>label height</p> <code>None</code> <code>ncols</code> <code>None | int</code> <p>number of columns</p> <code>None</code> <code>anchor_point</code> <code>None | Sequence[str]</code> <p>anchor point</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of pcompos</p>"},{"location":"reference/#pyradiance.pcond","title":"<code>pcond(hdr, human=False, acuity=False, veiling=False, sense=False, closs=False, center_weighted=False, linear=False, fixfrac=0.0, fixpoints=None, histo='', expval='', ldmax=100.0, lddyn=100.0, primaries=None, macbeth='', mapfile='')</code>","text":"<p>Condition a Radiance picture.</p> <p>Parameters:</p> Name Type Description Default <code>hdr</code> <code>Path</code> <p>input hdr</p> required <code>human</code> <code>bool</code> <p>Mimic human visual response. This is the same as turning on all acuity, veiling, sensitivity, and color loss.</p> <code>False</code> <code>acuity</code> <code>bool</code> <p>Defocus darker region.</p> <code>False</code> <code>veiling</code> <code>bool</code> <p>Add veiling glare.</p> <code>False</code> <code>sense</code> <code>bool</code> <p>Use human contrast sensitivity, simulating eye internal scattering.</p> <code>False</code> <code>center_weighted</code> <code>bool</code> <p>Use center-weighted average for acuity and veiling.</p> <code>False</code> <code>linear</code> <code>bool</code> <p>Use a linear reponse function instead of the standard dynamic range compression. This preseves the extremas.</p> <code>False</code> <code>fixfrac</code> <code>float</code> <p>Fixation fraction for acuity and veiling.</p> <code>0.0</code> <code>histo</code> <code>str</code> <p>Histogram file for acuity and veiling.</p> <code>''</code> <code>expval</code> <code>str</code> <p>Exposure value for acuity and veiling.</p> <code>''</code> <code>ldmax</code> <code>float</code> <p>Maximum luminance for acuity and veiling.</p> <code>100.0</code> <code>lddyn</code> <code>float</code> <p>Luminance dynamic range for acuity and veiling.</p> <code>100.0</code> <code>primaries</code> <code>None | list[float]</code> <p>Color primaries for color loss.</p> <code>None</code> <code>macbeth</code> <code>str</code> <p>Macbeth chart file for color loss.</p> <code>''</code> <code>mapfile</code> <code>str</code> <p>Color map file for color loss.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of pcond</p>"},{"location":"reference/#pyradiance.pfilt","title":"<code>pfilt(image, xres=None, yres=None, pixel_aspect=0, pa_correct=False, exposure=0, lamp=None, lampdat=None, one_pass=False, gaussian_filter_radius=None, limitfrac=None, hot_threshold=100, star_points=0, star_spread=0.0001, average_hot=False)</code>","text":"<p>filter a Radiance picture. By default, it uses two passes on the input, using a box filter.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str | Path | bytes</code> <p>input image</p> required <code>xres</code> <code>None | str</code> <p>horizontal resolution</p> <code>None</code> <code>yres</code> <code>None | str</code> <p>vertical resolution</p> <code>None</code> <code>pixel_aspect</code> <code>float</code> <p>pixel aspect ratio</p> <code>0</code> <code>exposure</code> <code>None | float</code> <p>exposure value</p> <code>0</code> <code>lamp</code> <code>None | str</code> <p>lamp file</p> <code>None</code> <code>lampdat</code> <code>None | str</code> <p>lamp data file</p> <code>None</code> <code>one_pass</code> <code>bool</code> <p>use one pass filter</p> <code>False</code> <code>gaussian_filter_radius</code> <code>None | float</code> <p>gaussian filter radius</p> <code>None</code> <code>limitfrac</code> <code>None | float</code> <p>limit fraction</p> <code>None</code> <code>hot_threshold</code> <code>float</code> <p>Set intensity considered 'hot', default 100 watts/sr/m2</p> <code>100</code> <code>star_points</code> <code>int</code> <p>Number of points on a start pattern.</p> <code>0</code> <code>star_spread</code> <code>float</code> <p>star pattern spread</p> <code>0.0001</code> <code>average_hot</code> <code>bool</code> <p>average hot spots</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of pfilt</p>"},{"location":"reference/#pyradiance.pkgbsdf","title":"<code>pkgbsdf(*xml, frozen=False, stdout=False)</code>","text":"<p>Pacakge BSDFs provided as XML for Radiance.</p> <p>Parameters:</p> Name Type Description Default <code>xml</code> <code>str | Path</code> <p>Path to XML files</p> <code>()</code> <code>frozen</code> <code>bool</code> <p>produce frozen octree instance for any detail geometry.</p> <code>False</code> <code>stdout</code> <code>bool</code> <p>print the output to stdout, only works for a single XML input.</p> <code>False</code> <p>Returns:</p> Type Description <code>None | bytes</code> <p>The output of the command</p>"},{"location":"reference/#pyradiance.pvalue","title":"<code>pvalue(pic, unique=False, original=False, header=True, resstr=True, skip=0, exposure=0, gamma=1.0, dataonly=False, outform='', reverse_rgb=False, interleaving=True, brightness=False, outprimary=None)</code>","text":"<p>convert RADIANCE picture to/from alternate formats Pvalue converts the pixels of a RADIANCE picture to or from another format. In the default mode, pixels are sent to the standard output, one per line, in the following ascii format: xpos ypos red  green     blue</p> <p>Parameters:</p> Name Type Description Default <code>pic</code> <code>Path | str | bytes</code> <p>hdr file path. Either path or stdin is used, path takes precedence.</p> required <code>unique</code> <code>bool</code> <p>if True, only unique values will be returned</p> <code>False</code> <code>original</code> <code>bool</code> <p>if True, print original values, before exposure compensation</p> <code>False</code> <code>header</code> <code>bool</code> <p>if True, header will be returned</p> <code>True</code> <code>resstr</code> <code>bool</code> <p>if True, resolution string will be returned</p> <code>True</code> <code>skip</code> <code>int</code> <p>number of bytes to skip</p> <code>0</code> <code>exposure</code> <code>int</code> <p>exposure value</p> <code>0</code> <code>gamma</code> <code>float</code> <p>gamma value</p> <code>1.0</code> <code>dataonly</code> <code>bool</code> <p>if True, only data will be returned</p> <code>False</code> <code>outform</code> <code>str</code> <p>output data format</p> <code>''</code> <code>reverse_rgb</code> <code>bool</code> <p>if True, RGB values will be reversed</p> <code>False</code> <code>interleaving</code> <code>bool</code> <p>if True, interleaving will be used</p> <code>True</code> <code>brightness</code> <code>bool</code> <p>if True, only brightness will be returned</p> <code>False</code> <code>outprimary</code> <code>None | str</code> <p>output color primaries</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of pvalue</p>"},{"location":"reference/#pyradiance.pvaluer","title":"<code>pvaluer(pic, xres=None, yres=None, inform='a', resstr=True, dataonly=False, header=True, primaries=None, pxyz=False)</code>","text":"<p>Run Radiance pvalue tools reverse mode: constructing a image from pixel values.</p> <p>Parameters:</p> Name Type Description Default <code>pic</code> <code>Path | str | bytes</code> <p>Path or bytes of the input pixel data.</p> required <code>xres</code> <code>None | int</code> <p>X resolution.</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>Y resolution.</p> <code>None</code> <code>inform</code> <code>str</code> <p>input data format. Default is \"a\" for ascii.</p> <code>'a'</code> <code>header</code> <code>bool</code> <p>Set to True if the picture file has a header. Default is False.</p> <code>True</code> <code>primaries</code> <code>None | list[float]</code> <p>list of primaries for XYZ calculation. Default is None.</p> <code>None</code> <code>pxyz</code> <code>bool</code> <p>Set to True to calculate XYZ values. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Bytes of the pvalue output</p>"},{"location":"reference/#pyradiance.ra_ppm","title":"<code>ra_ppm(inp, gamma=2.2, greyscale=False, reverse=False, exposure=0, ascii=False, outscale=255)</code>","text":"<p>convert RADIANCE picture to/from a Poskanzer Portable Pixmap</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>Path or bytes to input picture file.</p> required <code>gamma</code> <code>float</code> <p>Gamma value for the output image. Default is 2.2.</p> <code>2.2</code> <code>reverse</code> <code>bool</code> <p>Set to True to invoke a reverse conversion, from a PPM to a RADIANCE picture. Default is False.</p> <code>False</code> <code>exposure</code> <code>int</code> <p>Exposure value for the output image. Default is 0.</p> <code>0</code> <code>ascii</code> <code>bool</code> <p>Set to True to use ASCII Pixmap output. Default is False.</p> <code>False</code> <code>outscale</code> <code>int</code> <p>Output scale value. Default is 255.</p> <code>255</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of ra_ppm</p>"},{"location":"reference/#pyradiance.ra_tiff","title":"<code>ra_tiff(inp, out=None, gamma=2.2, greyscale=False, lzw=False, sgilog=False, sgilog24=False, ieee32=False, primary=False, exposure=0, reverse=False, xyze=False)</code>","text":"<p>ra_tiff - convert RADIANCE picture to/from a TIFF color or greyscale image</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>Path or bytes to input picture file.</p> required <code>out</code> <code>None | str</code> <p>Path to output file, required when output is a TIFF file.</p> <code>None</code> <code>gamma</code> <code>float</code> <p>Gamma value for the output image. Default is 2.2.</p> <code>2.2</code> <code>greyscale</code> <code>bool</code> <p>Set to True to convert to greyscale. Default is False.</p> <code>False</code> <code>lzw</code> <code>bool</code> <p>Set to True to use LZW compression. Default is False.</p> <code>False</code> <code>sgilog</code> <code>bool</code> <p>Set to True to use SGI log compression. Default is False.</p> <code>False</code> <code>sgilog24</code> <code>bool</code> <p>Set to True to use SGI log 24 compression. Default is False.</p> <code>False</code> <code>ieee32</code> <code>bool</code> <p>Set to True to use IEEE 32-bit floating point compression.</p> <code>False</code> <code>primary</code> <code>bool</code> <p>Set to True to use 16-bit/primary output. Default is False.</p> <code>False</code> <code>reverse</code> <code>bool</code> <p>Set to True to invoke a reverse conversion, from a TIFF to a RADIANCE picture. Default is False.</p> <code>False</code> <code>xyze</code> <code>bool</code> <p>Set to True to use XYZE output when invoking a reverse conversion. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>None | bytes</code> <p>output of ra_tiff</p>"},{"location":"reference/#pyradiance.rcalc","title":"<code>rcalc(inp, sep=None, inform=None, incount=1, outform=None, passive=False, pass_negative=False, inlimit=None, outlimit=None, source=None, expr=None, assign=None, exact_only=False, ignore_newlines=False, silent=False)</code>","text":"<p>Run rcalc</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path | bytes</code> <p>input data</p> required <code>sep</code> <code>None | str</code> <p>separator</p> <code>None</code> <code>inform</code> <code>None | str</code> <p>input format</p> <code>None</code> <code>incount</code> <code>int</code> <p>input count</p> <code>1</code> <code>outform</code> <code>None | str</code> <p>output format</p> <code>None</code> <code>passive</code> <code>bool</code> <p>passive mode</p> <code>False</code> <code>pass_negative</code> <code>bool</code> <p>pass negative</p> <code>False</code> <code>inlimit</code> <code>None | int</code> <p>input limit</p> <code>None</code> <code>outlimit</code> <code>None | int</code> <p>output limit</p> <code>None</code> <code>source</code> <code>None | str</code> <p>source file</p> <code>None</code> <code>expr</code> <code>None | str</code> <p>expression</p> <code>None</code> <code>assign</code> <code>None | str</code> <p>assign</p> <code>None</code> <code>exact_only</code> <code>bool</code> <p>exact only</p> <code>False</code> <code>ignore_newlines</code> <code>bool</code> <p>ignore newlines</p> <code>False</code> <code>silent</code> <code>bool</code> <p>silent</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of rcalc</p>"},{"location":"reference/#pyradiance.rcode_depth","title":"<code>rcode_depth(inp, ref_depth='1.0', inheader=True, outheader=True, inresolution=True, outresolution=True, xres=None, yres=None, inform='a', outform='a', decode=False, compute_intersection=False, per_point=False, depth_file=None, flush=False)</code>","text":"<p>Encode/decode 16-bit depth map.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path | bytes</code> <p>input file or bytes</p> required <code>ref_depth</code> <code>str</code> <p>reference distance, can be follow by /unit.</p> <code>'1.0'</code> <code>inheader</code> <code>bool</code> <p>Set to False to not expect header on input</p> <code>True</code> <code>outheader</code> <code>bool</code> <p>Set to False to not include header on output</p> <code>True</code> <code>inresolution</code> <code>bool</code> <p>Set to False to not expect resolution on input</p> <code>True</code> <code>outresolution</code> <code>bool</code> <p>Set to False to not include resolution on output</p> <code>True</code> <code>xres</code> <code>None | int</code> <p>x resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>y resolution</p> <code>None</code> <code>inform</code> <code>str</code> <p>input format</p> <code>'a'</code> <code>outform</code> <code>str</code> <p>output format when decoding</p> <code>'a'</code> <code>decode</code> <code>bool</code> <p>Set to True to decode instead</p> <code>False</code> <code>compute_intersection</code> <code>bool</code> <p>Set to True to compute intersection instead</p> <code>False</code> <code>per_point</code> <code>bool</code> <p>Set to True to compute per point instead of per pixel</p> <code>False</code> <code>depth_file</code> <code>None | str</code> <p>depth file</p> <code>None</code> <code>flush</code> <code>bool</code> <p>Set to True to flush output</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of rcode_depth</p>"},{"location":"reference/#pyradiance.rcode_ident","title":"<code>rcode_ident(inp, index_size=16, sep='\\n', decode=False, header=True, xres=None, yres=None, resstr=True, identifiers=False, indexes=False, per_point=False, flush=False)</code>","text":"<p>Store identifiers in an indexed map and retrieve from same</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path | bytes</code> <p>input file or bytes</p> required <code>index_size</code> <code>int</code> <p>index size</p> <code>16</code> <code>sep</code> <code>str</code> <p>separator</p> <code>'\\n'</code> <code>decode</code> <code>bool</code> <p>Set to True to decode instead</p> <code>False</code> <code>header</code> <code>bool</code> <p>Set to False to not to expect header on input; or not to include header on output when decoding</p> <code>True</code> <code>xres</code> <code>None | int</code> <p>x resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>y resolution</p> <code>None</code> <code>resstr</code> <code>bool</code> <p>Set to False to not include resolution string on output</p> <code>True</code> <code>identifiers</code> <code>bool</code> <p>Set to True to include identifiers on output</p> <code>False</code> <code>indexes</code> <code>bool</code> <p>Set to True to instead list identifiers indexes on output</p> <code>False</code> <code>per_point</code> <code>bool</code> <p>Set to True to compute per point instead of per pixel</p> <code>False</code> <code>flush</code> <code>bool</code> <p>Set to True to flush output after each identifier</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of rcode_ident</p>"},{"location":"reference/#pyradiance.rcode_norm","title":"<code>rcode_norm(inp, inheader=True, outheader=True, inresolution=True, outresolution=True, xres=None, yres=None, inform='a', outform='a', decode=False, per_point=False, norm_file=None, flush=False)</code>","text":"<p>Encode/decode 32-bit surface normal map.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>input file or bytes</p> required <code>inheader</code> <code>bool</code> <p>Set to False to not expect header on input</p> <code>True</code> <code>outheader</code> <code>bool</code> <p>Set to False to not include header on output</p> <code>True</code> <code>inresolution</code> <code>bool</code> <p>Set to False to not expect resolution on input</p> <code>True</code> <code>outresolution</code> <code>bool</code> <p>Set to False to not include resolution on output</p> <code>True</code> <code>xres</code> <code>None | int</code> <p>x resolution</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>y resolution</p> <code>None</code> <code>inform</code> <code>str</code> <p>input format</p> <code>'a'</code> <code>outform</code> <code>str</code> <p>output format when decoding</p> <code>'a'</code> <code>decode</code> <code>bool</code> <p>Set to True to decode instead</p> <code>False</code> <code>per_point</code> <code>bool</code> <p>Set to True to compute per point instead of per pixel</p> <code>False</code> <code>flush</code> <code>bool</code> <p>Set to True to flush output</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of rcode_norm</p>"},{"location":"reference/#pyradiance.render","title":"<code>render(scene, view=None, quality='Medium', variability='Medium', detail='Medium', nproc=1, ncssamp=3, resolution=None, ambbounce=0, ambcache=True, params=None)</code>","text":"<p>Render a scene.</p> <p>Parameters:</p> Name Type Description Default <code>scene</code> <p>Scene object.</p> required <code>quality</code> <code>str</code> <p>Quality level.</p> <code>'Medium'</code> <code>variability</code> <code>str</code> <p>Variability level.</p> <code>'Medium'</code> <code>detail</code> <code>str</code> <p>Detail level.</p> <code>'Medium'</code> <code>nproc</code> <code>int</code> <p>Number of processes to use.</p> <code>1</code> <code>ncssamp</code> <code>int</code> <p>Number of channels to sample</p> <code>3</code> <code>ambbounce</code> <code>int</code> <p>Number of ambient bounces.</p> <code>0</code> <code>ambcache</code> <code>bool</code> <p>Use ambient cache.</p> <code>True</code> <code>params</code> <code>None | RayParams</code> <p>Sampling parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>tuple[bytes, int, int]: output of render, width, height</p>"},{"location":"reference/#pyradiance.rfluxmtx","title":"<code>rfluxmtx(receiver, surface=None, rays=None, params=None, octree=None, scene=None)</code>","text":"<p>Run rfluxmtx command.</p> <p>Parameters:</p> Name Type Description Default <code>receiver</code> <code>str | Path</code> <p>receiver file path</p> required <code>surface</code> <code>None | str | Path</code> <p>input surface file path, mutually exclusive with rays</p> <code>None</code> <code>rays</code> <code>None | bytes</code> <p>input rays bytes, mutually exclusive with surface</p> <code>None</code> <code>params</code> <code>None | Sequence[str]</code> <p>ray tracing parameters</p> <code>None</code> <code>octree</code> <code>None | Path | str</code> <p>octree file path</p> <code>None</code> <code>scene</code> <code>None | Sequence[Path | str]</code> <p>list of scene files</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The results of rfluxmtx in bytes</p>"},{"location":"reference/#pyradiance.rlam","title":"<code>rlam(*inputs)</code>","text":"<p>Laminate records from multiple files.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>str | Path | bytes</code> <p>list of input files or bytes. There can only be one bytes input.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of rlam</p>"},{"location":"reference/#pyradiance.rmtxop","title":"<code>rmtxop(inp, outform='a', transpose=False, scale=None, transform=None, reflectance=None)</code>","text":"<p>Run rmtxop command.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <p>input</p> required <code>outform</code> <p>output format: 'a', 'f', 'd', 'c'</p> <code>'a'</code> <code>transpose</code> <p>whether to transpose matrix</p> <code>False</code> <code>scale</code> <p>scaling factor</p> <code>None</code> <code>transform</code> <p>transform factors for each channel</p> <code>None</code> <p>Returns:</p> Type Description <p>The results of rmtxop in bytes</p>"},{"location":"reference/#pyradiance.robjutil","title":"<code>robjutil(inp, radout=False, verbose=False, remove_texture_coordinates=False, remove_surface_normal=False, remove_surface_by_modifier=None, keep_surface_by_modifier=None, remove_surface_by_group=None, keep_surface_by_group=None, epsilon=None, triangulate=False, transform=None)</code>","text":"<p>Operate on Wavefront .OBJ file</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str | Path</code> <p>Input .OBJ file path</p> required <code>radout</code> <code>bool</code> <p>Output RADIANCE scene description</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Set to True to turn on verbosity</p> <code>False</code> <code>remove_texture_coordinates</code> <code>bool</code> <p>Remove texture coordinates from the output</p> <code>False</code> <code>remove_surface_normal</code> <code>bool</code> <p>Remove surface normal from the output</p> <code>False</code> <code>remove_surface_by_modifier</code> <code>None | Sequence[str]</code> <p>Remove surfaces by modifier, mutually exclusive with keep_surface_by_modifier</p> <code>None</code> <code>keep_surface_by_modifier</code> <code>None | Sequence[str]</code> <p>Keep surfaces by modifier, mutually exclusive with remove_surface_by_modifier</p> <code>None</code> <code>remove_surface_by_group</code> <code>None | Sequence[str]</code> <p>Remove surfaces by group/object, mutually exclusive with keep_surface_by_group</p> <code>None</code> <code>keep_surface_by_group</code> <code>None | Sequence[str]</code> <p>Keep surfaces by group/object, mutually exclusive with remove_surface_by_group</p> <code>None</code> <code>epsilon</code> <code>None | float</code> <p>Coalesce vertices that are within the given epsilon</p> <code>None</code> <code>triangulate</code> <code>bool</code> <p>Turns all faces with 4 or more sides into triangles</p> <code>False</code> <code>transform</code> <code>None | str</code> <p>Transform the input, using xform CLI syntax.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The output of the command</p>"},{"location":"reference/#pyradiance.rpict","title":"<code>rpict(view, octree, xres=None, yres=None, report=0, report_file=None, params=None)</code>","text":"<p>Get rpict command.</p> <p>Parameters:</p> Name Type Description Default <code>view</code> <code>Sequence[str]</code> <p>A list of view parameters in strings.</p> required <code>octree</code> <code>Path | str</code> <p>A path to octree file.</p> required <code>xres</code> <code>None | int</code> <p>X resolution.</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>Y resolution.</p> <code>None</code> <code>report</code> <code>float</code> <p>Report.</p> <code>0</code> <code>report_file</code> <code>None | Path</code> <p>Report file.</p> <code>None</code> <code>params</code> <code>None | Sequence[str]</code> <p>A list of additional parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>A bytes object.</p>"},{"location":"reference/#pyradiance.rsensor","title":"<code>rsensor(sensor, sensor_view=None, direct_ray=None, ray_count=None, octree=None, nproc=1, params=None)</code>","text":"<p>Compute sensor signal from a RADIANCE scene</p> <p>Parameters:</p> Name Type Description Default <code>sensor</code> <code>Sequence[str | Path]</code> <p>Sensor file</p> required <code>sensor_view</code> <code>None | Sequence[str | Path]</code> <p>Sensor view file</p> <code>None</code> <code>direct_ray</code> <code>None | Sequence[int]</code> <p>The number of rays sent to each light source per sensor</p> <code>None</code> <code>ray_count</code> <code>None | Sequence[int]</code> <p>The number of ray samples sent at random</p> <code>None</code> <code>octree</code> <code>None | str | Path</code> <p>Octree file</p> <code>None</code> <code>nproc</code> <code>int</code> <p>Number of processors to use</p> <code>1</code> <code>params</code> <code>None | Sequence[str]</code> <p>Additional parameters for rsensor command</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Output of rsensor command</p>"},{"location":"reference/#pyradiance.rtrace","title":"<code>rtrace(rays, octree, header=True, inform='a', outform='a', irradiance=False, irradiance_lambertian=False, outspec=None, trace_exclude='', trace_include='', trace_exclude_file=None, trace_include_file=None, uncorrelated=False, xres=None, yres=None, nproc=None, params=None, report=False, version=False)</code>","text":"<p>Run rtrace.</p> <p>Parameters:</p> Name Type Description Default <code>rays</code> <code>bytes</code> <p>A string of bytes representing the input rays.</p> required <code>octree</code> <code>Path | str</code> <p>Path to octree file.</p> required <code>header</code> <code>bool</code> <p>A boolean to indicate if the header should be included in the output.</p> <code>True</code> <code>inform</code> <code>str</code> <p>Input format. Default is 'a'.</p> <code>'a'</code> <code>outform</code> <code>str</code> <p>Output format. Default is 'a'.</p> <code>'a'</code> <code>irradiance</code> <code>bool</code> <p>A boolean to indicate if irradiance should be calculated.</p> <code>False</code> <code>irradiance_lambertian</code> <code>bool</code> <p>A boolean to indicate if irradiance should be calculated using Lambertian assumption.</p> <code>False</code> <code>outspec</code> <code>None | str</code> <p>Output specification. Default is None.</p> <code>None</code> <code>trace_exclude</code> <code>str</code> <p>A string of space separated material names to exclude from the trace.</p> <code>''</code> <code>trace_include</code> <code>str</code> <p>A string of space separated material names to include in the trace.</p> <code>''</code> <code>trace_exclude_file</code> <code>None | str | Path</code> <p>Path to a file containing material names to exclude from the trace.</p> <code>None</code> <code>trace_include_file</code> <code>None | str | Path</code> <p>Path to a file containing material names to include in the trace.</p> <code>None</code> <code>uncorrelated</code> <code>bool</code> <p>A boolean to indicate if uncorrelated sampling should be used.</p> <code>False</code> <code>xres</code> <code>None | int</code> <p>X resolution of the output image.</p> <code>None</code> <code>yres</code> <code>None | int</code> <p>Y resolution of the output image.</p> <code>None</code> <code>nproc</code> <code>None | int</code> <p>Number of processors to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>bytes</code> <p>A string of bytes representing the output of rtrace.</p>"},{"location":"reference/#pyradiance.spec_xyz","title":"<code>spec_xyz(*args, **kwargs)</code>","text":"<p>spec_xyz(arg0: collections.abc.Sequence[float], arg1: float, arg2: float, /) -&gt; tuple</p>"},{"location":"reference/#pyradiance.total","title":"<code>total(inp, mean=False, sumpower=0, multiply=False, find_max=False, find_min=False, inform=None, incount=1, outform=None, substep=None, substep_reset=True, inlimit=None, outlimit=None, sep=None)</code>","text":"<p>Sum up columns.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>None | str | Path</code> <p>input file or bytes</p> required <code>mean</code> <code>bool</code> <p>if True, the mean value will be calculated</p> <code>False</code> <code>sumpower</code> <code>int</code> <p>the power of the sum, mutally exclusive with multiply, find_max, and find_min</p> <code>0</code> <code>multiply</code> <code>bool</code> <p>if True, the values will be multiplied, mutally exclusive with sumpower, find_max, and find_min</p> <code>False</code> <code>find_max</code> <code>bool</code> <p>if True, the maximum value will be found, mutally exclusive with sumpower, multiply, and find_min</p> <code>False</code> <code>find_min</code> <code>bool</code> <p>if True, the minimum value will be found, mutally exclusive with sumpower, multiply, and find_max</p> <code>False</code> <code>inform</code> <code>None | str</code> <p>input format</p> <code>None</code> <code>incount</code> <code>int</code> <p>number of input values</p> <code>1</code> <code>outform</code> <code>None | str</code> <p>output format</p> <code>None</code> <code>substep</code> <code>None | int</code> <p>substep</p> <code>None</code> <code>substep_reset</code> <code>bool</code> <p>if True, the substep will be reset</p> <code>True</code> <code>inlimit</code> <code>None | int</code> <p>input limit</p> <code>None</code> <code>outlimit</code> <code>None | int</code> <p>output limit</p> <code>None</code> <code>sep</code> <code>None | str</code> <p>separator</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>output of total</p>"},{"location":"reference/#pyradiance.viewfile","title":"<code>viewfile(*args, **kwargs)</code>","text":"<p>viewfile(arg: str, /) -&gt; pyradiance.rad_params.View</p> <p>Read a view file into a View object</p>"},{"location":"reference/#pyradiance.vwrays","title":"<code>vwrays(pixpos=None, unbuf=False, outform='a', ray_count=1, pixel_jitter=0, pixel_diameter=0, pixel_aspect=1, xres=512, yres=512, dimensions=False, view=None, pic=None, zbuf=None)</code>","text":"<p>vwrays.</p>"},{"location":"reference/#pyradiance.write","title":"<code>write(file_path, data, overwrite=True, mode='wb')</code>","text":"<p>Write data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>path to file</p> required <code>data</code> <code>str | bytes</code> <p>data to write</p> required <code>overwrite</code> <code>bool</code> <p>if True, overwrite the file if it already exists</p> <code>True</code> <code>mode</code> <code>str</code> <p>'w' for text, 'wb' for binary</p> <code>'wb'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>path to file</p>"},{"location":"reference/#pyradiance.xyz_rgb","title":"<code>xyz_rgb(*args, **kwargs)</code>","text":"<p>xyz_rgb(arg0: float, arg1: float, arg2: float, /) -&gt; tuple</p>"},{"location":"tutorials/","title":"Quickstart","text":""},{"location":"tutorials/#importing-pyradiance","title":"Importing pyradiance","text":"<p>After installing pyradiance, it can be imported as follows: <pre><code>import pyradiance as pr\n</code></pre> We use an alias <code>pr</code> here to improve code readability.</p>"},{"location":"tutorials/#creating-a-scene","title":"Creating a scene","text":"<p>Here we are using RADIANCE files created beforehand to create a scene object used for rendering.</p> <p>First, we instantiate a <code>Scene</code> object by giving it a name.</p> <p><pre><code>scene = pr.Scene(\"ascene\")\n</code></pre> Next, we start adding materials and surfaces to the scene from local directories. <pre><code>scene.add_material(\"Objects/materials.mat\")\nscene.add_surface(\"Objects/walls.rad\")\nscene.add_surface(\"Objects/ceiling.rad\")\nscene.add_surface(\"Objects/floor.rad\")\n</code></pre> Similar, we add our light sources: <pre><code>scene.add_source(\"Sources/sky.rad\")\n</code></pre> In order to render a image, we'd also need to define camera/view. Here, we are defining a view at (1, 1, 1.5), facing (1, 0, 0). We use default values for the rest of the view parameters. <pre><code>aview = pr.create_default_view()\naview.vp = (1, 1.5, 1)\naview.vdir = (1, 0, 0)\n</code></pre> Then, we add this view to our scene. <pre><code>scene.add_view(aview)\n</code></pre></p> <p>Note</p> <p>Scene object here is only used for render() function. Regular RADIANCE functions such as rpict(),  rtrace(), rcontrib()  currently doesn't take <code>Scene</code> as input.  These 'raw' RADIANCE functions takes file paths as input instead, as they do in RADIANCE CLI.</p>"},{"location":"tutorials/#rendering-a-scene","title":"Rendering a scene","text":"<p>A scene can be rendering using the render() function. The <code>render()</code> function has a few optional arguments. RADIANCE, by default, uses zero ambient bounce, which we can overwrite by defining the <code>ambbounce</code> argument: <pre><code>image = pr.render(scene, ambbounce=1)\n</code></pre> The render function returns the generated <code>.hdr</code> image as bytes. </p>"},{"location":"tutorials/#visualizing-an-image","title":"Visualizing an image","text":"<p>We can visualize the image using popular computing and plotting library such as numpy and matplotlib.</p>"},{"location":"tutorials/#falscolor-image","title":"Falscolor image","text":"<p>Falsecolor-ing an image is a common practice in quantitative analysis. An falsecolor image maps the full range of an HDR image into a color scale. First, we convert our <code>image</code> into a numpy array. This is usually the first step before any analysis in Python, since most of the analysis and  visualization library recognize the <code>numpy.ndarray</code> object. We use pvalue() and  get_image_dimension() function for this step.  <pre><code>import numpy as np\nxres, yres = pr.get_image_dimensions(image)\npixels = pr.pvalue(image, header=False, outform='f', resstr=False)\niar = np.frombuffer(pixels, dtype=np.single).reshape(xres, yres, 3)\n</code></pre></p> <p>Note</p> <p>Notice the <code>outform</code> argument in the <code>pvalue()</code> function and <code>dtype</code> argument in the <code>np.frombuffer()</code> function need to match.  In this case, both are indicating the output and input data format to be single precision float. We also need to remove header and resolution string from the pvalue output.</p> <p>Now we have the image as numpy array, <code>iar</code>. The shape of this array is xres by yres by 3, where 3 represents the RGB channels. We are, however, usually interested in radiance or luminance values for each pixel. To do that we can weight the RGB channels to get our luminance values. This is trivial now with numpy array. <pre><code>luminance = iar[:, :, 0] * 47.4 + iar[:, :, 1] * 119.9 + iar[:, :, 2] * 11.6\n</code></pre> With the luminance values as another numpy array, we can use the matplotlib library to plot the image. <pre><code>import matplotlib.pyplot as plt\n\n# using a viridis color map\ncmap = plt.cm.viridis\n\n# setup a logrithm normalizer\nnorm = LogNorm()\n\nplt.axis(\"off\")\nfimage = cmap(norm(luminance))\nplt.colorbar(plt.cm.ScalarMappable(norm=norm, cmap=cmap), label=r\"$\\mathrm{cd/m^2}$\")\n</code></pre> </p>"},{"location":"tutorials/#tonemapping","title":"Tonemapping","text":"<p>We can use pcond() function to apply more advanced tonemapping  techniques, e.g., applying a human vision adaption. <code>pcond()</code> function, however, takes a image file as input, so we  need to write our <code>.hdr</code> image into a file before we can call <code>pcond()</code>. <pre><code>with open(\"raw.hdr\", \"wb\") as wtr:\n    wtr.write(image)\ntimage = pr.pcond(\"raw.hdr\", human=True)\n</code></pre> Next we can convert this tonemapped HDR into a numpy array and visualize it using matplotlib.  <pre><code>tpix = pr.pvalue(timage, header=False, resstr=False, outform='f')\ntiar = np.frombuffer(tpix, dtype=np.single).reshape(xres, yres, 3)\nplt.imshow(tiar*(1.0/2.2))\n</code></pre></p> <p>Note</p> <p>Notice we apply a 2.2 gamma correction here.</p> <p></p>"},{"location":"assets/sample_files/room/commandsWin/","title":"Index","text":"<p>An empty place holder for the path room\\commandsWin Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/","title":"Index","text":"<p>An empty place holder for the path room\\matrices Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/cds/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\cds Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/cds/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\cds\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/cds/hdrIllSpace/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\cds\\hdrIllSpace Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/cds/hdrLumFacade/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\cds\\hdrLumFacade Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dc/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dc Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dc/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dc\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dcd/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dcd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dcd/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dcd\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dmtx/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/dmtxd/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\dmtxd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/fmtx/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/fmtxd/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\fmtxd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/vmtx/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\vmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/vmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\vmtx\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/vmtxd/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\vmtxd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/vmtxd/hdrIllum/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\vmtxd\\hdrIllum Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/matrices/vmtxd/hdrLum/","title":"Index","text":"<p>An empty place holder for the path room\\matrices\\vmtxd\\hdrLum Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/octrees/","title":"Index","text":"<p>An empty place holder for the path room\\octrees Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/","title":"Index","text":"<p>An empty place holder for the path room\\results Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/3ph/","title":"Index","text":"<p>An empty place holder for the path room\\results\\3ph Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/3ph/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\3ph\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/3ph/varShad/","title":"Index","text":"<p>An empty place holder for the path room\\results\\3ph\\varShad Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/3ph/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\3ph Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/3ph/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\3ph\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/3phdir/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\3phdir Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/3phdir/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\3phdir\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/cds/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\cds Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/cds/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\cds\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/5ph/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\5ph\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/cds/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\cds Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/cds/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\cds\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/fmtx/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/fmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\fmtx\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/fmtxd/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\fmtxd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/fmtxd/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\fmtxd\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/6ph/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\6ph\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/cds/","title":"Index","text":"<p>An empty place holder for the path room\\results\\cds Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/cds/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\cds\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dc/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dc Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dc/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dc\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dc/views/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dc\\views Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/cds/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\cds Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/cds/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\cds\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/dc/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\dc Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/dc/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\dc\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/dcd/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\dcd Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/dcDDS/dcd/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\dcDDS\\dcd\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/fmtx/","title":"Index","text":"<p>An empty place holder for the path room\\results\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/results/fmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room\\results\\fmtx\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room/skyVectors/","title":"Index","text":"<p>An empty place holder for the path room\\skyVectors Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/commandsWin/","title":"Index","text":"<p>An empty place holder for the path room2\\commandsWin Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/matrices/","title":"Index","text":"<p>An empty place holder for the path room2\\matrices Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/matrices/dmtx/","title":"Index","text":"<p>An empty place holder for the path room2\\matrices\\dmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/matrices/fmtx/","title":"Index","text":"<p>An empty place holder for the path room2\\matrices\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/matrices/vmtx/","title":"Index","text":"<p>An empty place holder for the path room2\\matrices\\vmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/matrices/vmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room2\\matrices\\vmtx\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/octrees/","title":"Index","text":"<p>An empty place holder for the path room2\\octrees Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/results/","title":"Index","text":"<p>An empty place holder for the path room2\\results Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/results/fmtx/","title":"Index","text":"<p>An empty place holder for the path room2\\results\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/results/fmtx/windowGroups/","title":"Index","text":"<p>An empty place holder for the path room2\\results\\fmtx\\windowGroups Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room2/skies/","title":"Index","text":"<p>An empty place holder for the path room2\\skies Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/commandsWin/","title":"Index","text":"<p>An empty place holder for the path room3\\commandsWin Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/matrices/","title":"Index","text":"<p>An empty place holder for the path room3\\matrices Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/matrices/dmtx/","title":"Index","text":"<p>An empty place holder for the path room3\\matrices\\dmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/matrices/fmtx/","title":"Index","text":"<p>An empty place holder for the path room3\\matrices\\fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/matrices/vmtx/","title":"Index","text":"<p>An empty place holder for the path room3\\matrices\\vmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/matrices/vmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room3\\matrices\\vmtx\\hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/octrees/","title":"Index","text":"<p>An empty place holder for the path room3\\octrees Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/results/","title":"Index","text":"<p>An empty place holder for the path room3\\results Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/results/fmtx/","title":"Index","text":"<p>An empty place holder for the path room3/results/fmtx Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/results/fmtx/hdr/","title":"Index","text":"<p>An empty place holder for the path room3/results/fmtx/hdr Additional notes maybe added later.</p>"},{"location":"assets/sample_files/room3/skies/","title":"Index","text":"<p>An empty place holder for the path room3\\skies Additional notes maybe added later.</p>"},{"location":"howtos/","title":"Index","text":"<p>Pyradiance how-to guides</p> <ul> <li>BSDF analysis</li> </ul>"},{"location":"howtos/bsdf/","title":"How to parse and query a tabulated BSDF file (.xml)","text":"<p><code>Pyradiance</code> <code>BSDF</code> object provides a host of methods for parsing and analyzing a tabulated BSDF file. See sectons below for examples. You can instantiate a <code>BSDF</code> object by giving the file path to the BSDF (.xml) file.</p> <p>You can either plainly instantiate the object like so:</p> <pre><code>import pyradiance as pr\nsd = pr.BSDF(\"bsdf.xml\")\n</code></pre> <p>You can also instantiate the BSDF object in a context manager, which will clear for you the memory associated with the loaded BSDF once done:</p> <pre><code>with pr.BSDF('bsdf.xml') as sd:\n    ...\n</code></pre>"},{"location":"howtos/bsdf/#basic-information","title":"Basic information","text":"<p>A BSDF object has two attribtues desecribing basic information about the BSDF: <code>info</code> and <code>components</code>. Here is an example of accessing the information:</p> <p><pre><code>with pr.BSDF('bsdf.xml') as sd:\n    info  = sd.info\n    cp = sd.components\n</code></pre> Here are the results: <pre><code>&gt;&gt;&gt; print(info)\nMaterials: Name\nManufacturer: Manufacturer\nWidth x Height x Thickness (m): 0.0 x 0.0 x 0.0\nHas geometry: no\n&gt;&gt;&gt; print(cp)\nPeak front hemispherical reflectance: 0.48338043257526025\nPeak front hemispherical transmittance: 0.09124324694247694\nDiffuse front reflectance: (0.3883772003721621, 0.3883772003721621, 0.3883771656485355)\nDiffuse back reflectance: (0, 0, 0)\nDiffuse front transmittance: (0, 0, 0)\nDiffuse back transmittance: (0, 0, 0)\n</code></pre></p>"},{"location":"howtos/bsdf/#direct-hemispherical-values","title":"Direct hemispherical values","text":"<pre><code>with pr.BSDF(\"bsdf.xml\") as sd:\n    sd.direct_hemi(0, 0, 't')  # direct hemispherical transmittance at theta=0\u00b0, phi=0\u00b0\n    sd.direct_hemi(30, 0, 'r')  # direct hemispherical reflectance at theta=30\u00b0, phi=0\u00b0\n    sd.direct_hemi(40, 45, 'ts')  # direct - direct transmittance at theta=45\u00b0, phi=45\u00b0\n</code></pre>"},{"location":"howtos/bsdf/#querying-the-projected-solid-angle-given-an-incident-angle","title":"Querying the projected solid angle given an incident angle","text":"<p>You can query the scattering solid angle of a given incident direction. Here is an example of query and minimum and maximum solid angle at normal incidence.</p> <pre><code>with pr.BSDF('bsdf.xml') as sd:\n    min, max = sd.size(0, 0)\n</code></pre> <p>You can also specify the outgoing angle as well and, as a result, the minimum and maximum angle will be the same. <pre><code>with pr.BSDF('bsdf.xml') as sd:\n    min, max = sd.size(0, 0, t2=180, p2=0)\n</code></pre></p>"},{"location":"howtos/bsdf/#evaluating-the-bsdf-given-an-incident-and-outgoing-angle","title":"Evaluating the BSDF given an incident and outgoing angle","text":"<p>You can also explicitly evaulate the BSDF at a given incident and outgoing angle.</p> <p>Here is an example of evaluating a BSDF with an incident theta=30\u00b0, phi=45\u00b0 and outgoing theta=145\u00b0, phi=90\u00b0.</p> <pre><code>with pr.BSDF('bsdf.xml') as sd:\n    sval = sd.eval(30, 45, 145, 90)\n</code></pre>"},{"location":"howtos/bsdf/#generating-random-scattering-samples-given-an-incident-direction","title":"Generating random scattering samples given an incident direction","text":"<p>You can generate N random scattering sample given an incident direction. You'd also need to specify the type of the hemispherical values.</p> <p>Here is an example of generating 10 transmittance samples with an incident theta=30\u00b0, phi=45\u00b0.</p> <pre><code>with pr.BSDF(\"bsdf.mxl\") as sd:\n    vecs, clrs = sd.samples(30, 45, 10, 't')\n</code></pre>"},{"location":"howtos/guide1/","title":"How to load a WaveFront (.obj) model","text":""},{"location":"howtos/guide1/#load-obj","title":"Load .obj","text":"<pre><code>room = pr.robjutil(\"room.obj\")\n</code></pre>"},{"location":"howtos/guide1/#define-obj-materials","title":"Define .obj materials","text":"<p>Getting all the modifiers <pre><code>[p.omod for p in pr.read_rad(room)]\n</code></pre> Displaying all the modifiers that we need to define <pre><code>\n</code></pre> <pre><code>primitives = []\nprimitives.append(Primitive(\"void\", \"plastic\", \"white50\", [], [.5, .5, .5, 0, 0]))\nprimitives.append(Primitive(\"void\", \"plastic\", \"white50\", [], [.5, .5, .5, 0, 0]))\nprimitives.append(Primitive(\"void\", \"plastic\", \"white50\", [], [.5, .5, .5, 0, 0]))\nprimitives.append(Primitive(\"void\", \"plastic\", \"white50\", [], [.5, .5, .5, 0, 0]))\n</code></pre></p>"},{"location":"howtos/guide1/#create-an-octree","title":"Create an octree","text":"<pre><code>with open(\"room.oct\", \"wb\") as wtr:\n    wtr.write(pr.oconv(primitives, stdin=True))\n</code></pre>"},{"location":"howtos/guide1/#trace-a-ray","title":"Trace a ray","text":"<pre><code>pr.rtrace(b\"0 0 0 0 0 1\", \"room.oct\")\n</code></pre>"}]}